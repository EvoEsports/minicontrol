# ui2 â€” JSX-style UI primitives & Manialink integration ðŸŽ®

**Location:** `core/ui/*` (notably `manialink.ts` and `forge.ts`)

## Overview
`ui2` is the lightweight UI layer used by MINIcontrol for building Manialink-based interfaces using JSX-style components and a small runtime that collects Maniascript from components.

Key pieces:
- `Manialink` class â€” manages manialink lifecycle (render, display, hide, destroy) and integrates with the `forge` renderer to produce final XML.
- `forge` (see `forge.md`) â€” provides JSX helpers, hooks, and render utilities.

## Manialink class (quick reference)

```ts
import Manialink from '@core/ui/manialink';

const widget = new Manialink(() => <frame>...</frame>);
await widget.display();
await widget.hide();
await widget.destroy();
```

### Important methods & props
- `id` â€” unique autogenerated id; useful for debugging
- `display()` â€” show the manialink (first display triggers `tmc.ui.displayManialink`)
- `hide()` â€” hide it from players
- `destroy(hide = true)` â€” teardown and ask UI manager to remove references
- `render()` â€” produces the manialink XML (internal; uses `renderJsx` and runs hook commit phases)
- `cleanReferences()` â€” runs `disposeScript` and clears fields for GC

### How rendering works (high-level)
1. `Manialink.render()` creates/gets a `root` object storing `hooks` and `dataObj`.
2. It sets the current root (so `getProperties()` works) and calls the component function to produce a virtual element tree.
3. `renderJsx()` converts the tree to XML and returns it.
4. `render()` then commits effects: runs header effects first (collected via `setScriptHeader`), then body effects (via `setScript`).
5. Headers and scripts are deduplicated and combined into a single `<script>` block inside the manialink.

## Example: Creating a live-updating widget
````tsx
// userdata/plugins/example-plugin/ui/mywidget.tsx
import { createElement as h, maniascriptFragment, setScript, getProperties } from '@core/ui/forge';
import Manialink from '@core/ui/manialink';

function WidgetContent() {
  const props = getProperties();

  // Register periodic script only when a dependency changes
  setScript(() => {
    return `
    main() {
      // This code will be merged into the manialink script body
      while(True) {
        // perform updates
        yield;
      }
    }
    `;
  }, [JSON.stringify(props.data)]);

  return (
    <frame>
      <label text="Widget active" />
      <script>{maniascriptFragment(`// inline script for small snippets`)}</script>
    </frame>
  );
}

// Create and show
const ml = new Manialink(() => <WidgetContent />);
await ml.display();
````

## Integration & plugin notes
- `dataObj` attached to the root can be used to pass per-manialink data (accessible via `getProperties()` in components).
- To allow plugin-based customizations, register component overrides using `registerComponent(name, comp)`.
- Clean up with `disposeScript()` and `manialink.destroy()` to ensure no lingering cleanup references remain.

## Debugging tips
- Inspect `roots` from `forge.ts` during runtime to see active roots and their `hooks`.
- Use `getRegisteredComponents()` to review overrides.
- Use `maniascriptFragment()` to ensure injected snippets are preserved in output.

---

See `documentation/devs/forge.md` for full API details and examples for the hook system.