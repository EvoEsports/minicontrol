{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Home","text":""},{"location":"#minicontrol-documentation","title":"MINIcontrol Documentation","text":"<p>Welcome! MINIcontrol is a lightweight controller for Trackmania servers designed for modular plugin-based extensibility. This documentation is organized for two main audiences:</p> <ul> <li>Server Admins \u2014 installation, deployment, and plugin management.</li> <li>Plugin Developers \u2014 API references, plugin lifecycle, UI components, and examples.</li> </ul> <p>Need help? Join the Evo Esports Discord in the <code>#minicontrol</code> channel or open an issue on GitHub.</p> <p>View the live docs site: https://evoesports.github.io/minicontrol</p>"},{"location":"#quick-links","title":"Quick links","text":"<ul> <li>Server Admins: Installation &amp; Setup \u2705</li> <li>Plugin Managers: Plugin management guide</li> <li>Developers: Concept &amp; architecture \u2022 Plugins &amp; API</li> <li>UI System: JSX \u2022 Forge API</li> <li>Class reference: Core classes index</li> <li>Examples: Quickstart plugin and example plugin</li> </ul>"},{"location":"#repository-reference-links","title":"Repository &amp; Reference Links","text":"<ul> <li>Full repo: https://github.com/EvoEsports/minicontrol</li> <li>Releases &amp; changelog: https://github.com/EvoEsports/minicontrol/releases</li> <li>Project README: README.md</li> </ul>"},{"location":"#what-youll-find-here","title":"What you'll find here","text":"<ul> <li>A concise install guide (Node/Bun and Docker)</li> <li>Plugin lifecycle and the manifest/resolver system</li> <li>UI helpers for creating Manialinks, Widgets and Windows</li> <li>Managers for Players, Maps, Settings, Commands, Bills</li> <li>GBX XML-RPC integration (server transport layer)</li> <li>Migration &amp; database guidance (SQLite local/dev and Postgres/MySQL for production)</li> </ul>"},{"location":"#quick-start-top-tasks","title":"Quick Start (top tasks)","text":"<ol> <li>Clone repo and install dependencies:</li> </ol> <pre><code>git clone https://github.com/EvoEsports/minicontrol.git\ncd minicontrol\nnpm install\n</code></pre> <ol> <li>Copy the environment file and configure credentials:</li> </ol> <pre><code>cp .env.example .env\n# (Windows) PowerShell: Copy-Item .env.example .env\n</code></pre> <ol> <li>Run database migrations and start the controller in dev/production:</li> </ol> <pre><code>npm run migrate\nnpm start            # production (tsx)\nnpm run dev          # development (bun watch)\n</code></pre>"},{"location":"#recommended-next-steps","title":"Recommended next steps","text":"<ul> <li>For admins: follow the Install guide and review PLUGINS control.</li> <li>For developers: read Concept then the Plugins guide.</li> <li>Check sample <code>userdata/plugins/example-plugin</code> for a minimal plugin skeleton and templates.</li> </ul>"},{"location":"#compatibility-requirements","title":"Compatibility &amp; requirements","text":"<ul> <li>Node.js &gt;= 21.5.0 (recommended) or Bun (dev); <code>tsx</code> is used in the runtime to execute TypeScript.</li> <li>SQLite is used by default for quick local setups; for production use PostgreSQL or MySQL (set <code>DATABASE</code> accordingly).</li> <li>Supported server platforms include Trackmania (TM2020/TM2) and TmForever. Verify compatibility with plugin <code>requiresMinicontrolVersion</code>.</li> </ul> <p>For detailed install and production recommendations, see the Install guide.</p>"},{"location":"#contributing-reporting-support","title":"Contributing, Reporting &amp; Support","text":"<ul> <li>Have a question or need help? Join the Evo Esports Discord: https://discord.gg/evoesports</li> <li>Found a bug? Open an issue: https://github.com/EvoEsports/minicontrol/issues</li> <li>PRs welcome: please open an issue first to discuss significant changes.</li> </ul>"},{"location":"#license","title":"License","text":"<p>MINIcontrol is released under the terms shown in the <code>LICENSE</code> file. Please review before contributing.</p>"},{"location":"devs/concept/","title":"MINIcontrol for developers","text":"<p>MINIcontrol is a modern, modular server controller designed to work across the various Trackmania titles. It provides a lightweight framework and a consistent plugin API so server operators and developers can manage servers, build features, and author plugins with minimal friction.</p> <p>The project began as a response to the limitations of older server controllers. XAseco \u2014 long the most widely used controller \u2014 is built on legacy PHP versions, and attempts to port it to newer PHP runtimes often break compatibility with existing plugins. While alternatives such as Trakman exist, they did not fully meet the modularity and plugin-compatibility goals we wanted.</p> <p>To address these issues, reaby started MINIcontrol to deliver a future-proof controller with a single codebase able to support multiple Trackmania games. Evo Esports later adopted the project and contributed development resources to accelerate development and broaden the feature set.</p> <p>One of MINIcontrol's core principles is cross-game plugin compatibility: plugins should work across multiple Trackmania titles with the same code. This is achievable because the Dedicated Server's XML-RPC API has remained relatively stable, and the controller provides small adapters to normalize differences between games.</p> <p>This isn't our first server controller project \u2014 we have worked on several prior controllers (MLEPP, Expansion, Expansion\u00b2, EvoSC, and others) \u2014 and we've learned many lessons that shaped MINIcontrol's architecture and design.</p>"},{"location":"devs/concept/#core","title":"Core","text":"<p>The core of MINIcontrol is intentionally compact and focused: it provides the essential runtime services and a stable foundation that plugin authors rely on. The core handles low-level tasks such as connecting to the dedicated server (GBX/XML-RPC), normalizing events across Trackmania titles, managing a small set of first-class managers (maps, players, UI, settings, bills), and providing a safe plugin lifecycle and loader for installing, resolving, and loading plugins.</p> <p>Key responsibilities of the core include:</p> <ul> <li>Server connection and transport: A GBX client that wraps XML-RPC interactions and normalizes server method names for different game families.</li> <li>Event normalization: Converts different server callbacks and modescripts into unified <code>TMC.*</code> events for plugin authors.</li> <li>Plugin lifecycle, discovery and resolution: Scans standard plugin directories, validates <code>manifest.json</code>, resolves dependency graphs using semver ranges, and loads plugins in deterministic order.</li> <li>Built-in managers: Lightweight managers provide common services (players, maps, UI, settings, billing, and more) that plugins use to avoid reimplementing core functionality.</li> <li>Logging and telemetry: Centralized logging, optional Sentry integration, and consistent debug/logging utilities.</li> <li>Database manager: Handles DB connection, migrations (Umzug + Sequelize) and exposes models under <code>core/schemas/*</code>. Registers standard models such as <code>players</code> and <code>map</code> and keeps runtime sync between server state and the DB.</li> </ul> <p>The core intentionally avoids implementing high-level features directly \u2014 instead it exposes a simple, opinionated API and helpers (like <code>addListener</code>, <code>addCommand</code>, <code>addSetting</code>) so plugins can register functionality cleanly and the runtime can manage resources and lifecycle events safely.</p> <p>This approach keeps the core small and maintainable while enabling a rich ecosystem of plugins that implement features on top of the same stable API.</p>"},{"location":"devs/concept/#overview-of-the-folder-structure","title":"Overview of the folder structure","text":"<ul> <li>\ud83d\udcc2 minicontrol</li> <li>\ud83d\udcc1 core  - core contains all built-in classes and also plugins MINIcontrol ships with<ul> <li>\ud83d\udcc4 minicontrol.ts - entry for controller</li> <li>\ud83d\udcc4 billmanager.ts - BillManager class</li> <li>\ud83d\udcc4 commandmanager.ts - CommandManager class</li> <li>\ud83d\udcc4 mapmanager.ts - MapManager class</li> <li>\ud83d\udcc4 playermanager.ts - PlayerManager class</li> <li>\ud83d\udcc4 settingsmanager.ts - SettingsManager class</li> <li>\ud83d\udcc4 database.ts - Database manager</li> <li>\ud83d\udcc4 server.ts - Server class</li> <li>\ud83d\udcc4 menu.ts - Menu class</li> <li>\ud83d\udcc4 uimanager.ts - UIManager class</li> <li>\ud83d\udcc4 plugins/ - Plugins guide</li> <li>\ud83d\udcc4 gbx/ - GBX client</li> <li>\ud83d\udcc4 log.ts - Logger</li> <li>\ud83d\udcc4 sentry.ts - Sentry integration</li> <li>\ud83d\udcc4 utils.ts - Utilities &amp; helpers</li> <li>\ud83d\udcc4 quickstart-plugin.md - Plugin Quickstart</li> <li>\ud83d\udcc4 class/index.md - All core class docs</li> <li>\ud83d\udcc4 schemas/ - Sequelize models (e.g., <code>map.model.ts</code>, <code>players.model.ts</code>) and migration hooks</li> </ul> </li> <li>\ud83d\udcc1 documentation  - this folder</li> <li>\ud83d\udcc1 docker - Dockerfile and example Docker Compose</li> <li>\ud83d\udcc1 userdata - contains all user data, e.g. the db migrations and schemas, the .sqlite file and user-installed plugins</li> <li>\ud83d\udcc4 .env - environmental variables for config</li> </ul>"},{"location":"devs/concept/#trackmania-mini-control-the-tmc-global-variable","title":"Trackmania Mini Control - the <code>tmc</code> global variable","text":"<p><code>tmc</code> is available for everywhere and should be always used to interact with the dedicated server, plugins, database and such.</p>"},{"location":"devs/concept/#quick-reference-table","title":"Quick reference table","text":"Variable Type Short description Example <code>tmc.server</code> Server Main server call wrapper; use <code>call</code>, <code>send</code>, <code>multicall</code> <code>await tmc.server.call('GetCurrentMapInfo')</code> <code>tmc.players</code> PlayerManager Player cache &amp; lookups <code>await tmc.players.getPlayer(login)</code> <code>tmc.ui</code> UiManager Display UI, add actions, clipboard <code>tmc.ui.setClipboard(login, text)</code> <code>tmc.maps</code> MapManager Maplist helpers and map info <code>tmc.maps.currentMap</code> <code>tmc.chatCmd</code> CommandManager Add/remove commands <code>tmc.addCommand('/hello', cb)</code> <code>tmc.settings</code> SettingsManager Persistent settings and colors <code>tmc.settings.set('tmf.hud.round_scores', true)</code> <code>tmc.database</code> Database DB connection + models (Sequelize). Use <code>tmc.database.sequelize</code> or <code>tmc.database.addModels([...])</code> <code>await tmc.database.syncPlayers()</code> <code>tmc.plugins</code> { [key: string]: Plugin } Loaded plugin instances <code>tmc.plugins['example']</code> <code>tmc.admins</code> string[] List of admin logins <code>tmc.admins.includes(login)</code> <code>tmc.game</code> object Dedicated server game info (<code>Name</code>) <code>if (tmc.game.Name === 'TmForever')</code> <code>tmc.storage</code> any Runtime shared key-value store <code>tmc.storage['minicontrol.foo'] = 'bar'</code>"},{"location":"devs/concept/#public-variables","title":"Public variables","text":"<p>Below are the <code>tmc</code> global variables available everywhere in plugins and core code. Each entry includes a short description and a cross-link to the relevant class or documentation.</p> <ul> <li><code>tmc.admins</code> \u2014 string[] | List of admin logins maintained by <code>SettingsManager</code>.</li> <li>Example: <code>if (tmc.admins.includes(login)) { /* allow admin action */ }</code></li> <li> <p>See: SettingsManager class</p> </li> <li> <p><code>tmc.version</code> \u2014 string | The controller runtime version (from package.json / version.json).</p> </li> <li> <p>Example: <code>tmc.cli(</code>MINIcontrol ${tmc.version}<code>)</code></p> </li> <li> <p><code>tmc.startTime</code> \u2014 number | Controller start timestamp (ms since epoch) useful for uptime calculation.</p> </li> <li> <p>Example: <code>const upSeconds = Math.floor((Date.now()-tmc.startTime)/1000);</code></p> </li> <li> <p><code>tmc.server</code> \u2014 Server | All server calls (XMLRPC) and event listener helper.</p> </li> <li>Example: <code>await tmc.server.call('GetCurrentMapInfo');</code></li> <li> <p>See: Server class</p> </li> <li> <p><code>tmc.players</code> \u2014 PlayerManager | Player helpers, caches and utilities.</p> </li> <li>Example: <code>const players = tmc.players.getAll(); const player = await tmc.players.getPlayer(login);</code></li> <li> <p>See: PlayerManager class</p> </li> <li> <p><code>tmc.ui</code> \u2014 UiManager | UI helpers for displaying manialinks, widgets and windows.</p> </li> <li>Example: <code>await tmc.ui.displayManialink(widget); tmc.ui.setClipboard(login, text);</code></li> <li> <p>See: UiManager class</p> </li> <li> <p><code>tmc.chatCmd</code> \u2014 CommandManager | Chat command registration and execution.</p> </li> <li>Example: <code>tmc.addCommand('/hello', (login) =&gt; tmc.chat('Hi', login));</code></li> <li> <p>See: CommandManager class</p> </li> <li> <p><code>tmc.maps</code> \u2014 MapManager | Map list helpers with <code>get()</code>, <code>getMap(uid)</code>, <code>currentMap</code> and <code>nextMap</code> properties.</p> </li> <li>Example: <code>const mp = tmc.maps.getMap(uid); const current = tmc.maps.currentMap;</code></li> <li> <p>See: MapManager class</p> </li> <li> <p><code>tmc.plugins</code> \u2014 { [key: string]: Plugin } | Dictionary of loaded plugin instances keyed by ID. Prefer using public APIs over calling plugin internals directly.</p> </li> <li>Example: <code>if (tmc.plugins['example']) { await tmc.plugins['example'].someMethod(); }</code></li> <li> <p>See: Plugin base &amp; loader</p> </li> <li> <p><code>tmc.game</code> \u2014 object | Runtime game info obtained from the dedicated server, e.g. <code>tmc.game.Name</code>.</p> </li> <li> <p>Example: <code>if (tmc.game.Name === 'TmForever') { /* tmf specific */ }</code></p> </li> <li> <p><code>tmc.mapsPath</code> \u2014 string | Absolute path to the dedicated server's map directory for file operations.</p> </li> <li> <p>Example: <code>tmc.cli(</code>Maps folder: ${tmc.mapsPath}<code>)</code></p> </li> <li> <p><code>tmc.storage</code> \u2014 { [key: string]: any } | A small global key-value store that persists only in runtime memory and is shared across plugins.</p> </li> <li> <p>Example: <code>tmc.storage['minicontrol.someKey'] = 'value'; const v = tmc.storage['minicontrol.someKey'];</code></p> </li> <li> <p><code>tmc.database</code> \u2014 Database | Sequelize instance, models and sync helpers. Plugins can register models via <code>tmc.database.addModels([...])</code>.</p> </li> <li>Example: <code>await tmc.database.syncPlayers()</code></li> </ul> <p>Note: Use the provided manager classes to access runtime data instead of relying on plugin internals where possible; this improves maintainability and reduces risk of breaking changes.</p>"},{"location":"devs/concept/#public-methods","title":"Public methods","text":"<pre><code>interface MiniControl {\n  // Get player by login\n  async getPlayer(login: string): Promise&lt;Player&gt;;\n\n  // Command helpers (wrapping CommandManager)\n  addCommand(command: string, callback: CallableCommand, help?: string): void;\n  removeCommand(command: string): void;\n\n  // Plugin lifecycle helpers\n  findPlugin(name: string): string | null;\n  discoverPlugins(): Promise&lt;{ id: string; path: string; manifest?: any; compatible?: boolean; loaded?: boolean }[]&gt;;\n  listPlugins(): Promise&lt;{ id: string; path: string; manifest?: any; compatible?: boolean; loaded?: boolean }[]&gt;;\n  installPlugin(fromPath: string): Promise&lt;string&gt;;\n  removePlugin(id: string): Promise&lt;void&gt;;\n  loadPlugin(name: string): Promise&lt;void&gt;;\n  unloadPlugin(name: string): Promise&lt;void&gt;;\n\n  // Logging / debugging / chat\n  cli(object: any): void;\n  debug(object: any): void;\n  chat(text: string, login?: undefined | string | string[]): void;\n}\n</code></pre>"},{"location":"devs/concept/#database-manager","title":"Database manager","text":"<p>The Database manager centralizes runtime database access and migration handling. Key points:</p> <ul> <li>Initialization is optional and only runs when <code>DATABASE</code> is set in <code>.env</code>. During <code>tmc.database.init()</code> it connects, runs migrations, and registers models.</li> <li>Built-in models are in <code>core/schemas/*</code> (e.g. <code>map.model.ts</code>, <code>players.model.ts</code>). Plugins should register additional Sequelize models using <code>tmc.database.addModels([MyModel])</code>.</li> <li>Migrations: the controller runs Umzug migrations from three locations:</li> <li><code>./core/migrations/*.ts</code> \u2014 core migrations</li> <li><code>./userdata/migrations/*.ts</code> \u2014 user-level migrations</li> <li><code>./userdata/plugins/**/migrations/*.ts</code> \u2014 plugin-provided migrations</li> <li>The database manager emits event-driven sync and registers listeners for <code>TMC.PlayerConnect</code>, <code>TMC.PlayerDisconnect</code>, and <code>Trackmania.EndMap</code> to persist runtime data to DB.</li> <li>Runtime commands added by the Database manager include <code>/active</code> and <code>/topactive</code>.</li> </ul> <p>Plugin author recommendations:</p> <ul> <li>Prefer using model classes from <code>core/schemas/*</code> for common tables (players, maps) to maintain compatibility.</li> <li>When registering models from a plugin, call <code>tmc.database.addModels([MyModel])</code> during <code>onLoad()</code> so models are discovered and used by the running Sequelize instance.</li> <li>Avoid direct raw SQL unless required; prefer model APIs for queries, transactions and updates.</li> </ul> <p>Notes &amp; troubleshooting:</p> <ul> <li>Supported DB drivers: <code>sqlite</code>, <code>mysql</code>, <code>postgres</code> as parsed from <code>DATABASE</code> env prefix.</li> <li>Migrations are run at startup and will cause the process to exit on failure \u2014 test migrations locally before deploying.</li> <li>If you need to add long-running imports or heavy parse work (like GBX parsing for map vehicles), do it lazily or in a background async task to avoid blocking startup.</li> </ul>"},{"location":"devs/forge/","title":"Forge \u2014 JSX renderer &amp; hooks \ud83d\udd27","text":"<p>Location: <code>core/ui/forge.ts</code></p>"},{"location":"devs/forge/#what-is-forge","title":"What is Forge?","text":"<p>Forge implements a lightweight JSX-like renderer for producing Manialink XML and in-manialink Maniascript code. It provides:</p> <ul> <li>A tiny virtual-DOM shape via <code>createElement</code>/<code>jsx</code>/<code>jsxs</code> and <code>Fragment</code>.</li> <li>A hooks-like system (<code>setScript</code>, <code>setScriptHeader</code>) to register Maniascript strings or cleanup functions during render.</li> <li>Utilities to build safe Maniascript fragments and to register/override components at runtime.</li> </ul>"},{"location":"devs/forge/#quick-import","title":"Quick import","text":"<pre><code>import { createElement, Fragment, setScript, setScriptHeader, getComponent, registerComponent, getProperties, maniascriptFragment } from '@core/ui/forge';\n</code></pre>"},{"location":"devs/forge/#core-functions-behavior","title":"Core functions &amp; behavior","text":"<ul> <li><code>createElement(type, props, ...children)</code> \u2014 create a virtual element object.</li> <li><code>Fragment(props)</code> \u2014 passthrough container for lists of children.</li> <li><code>jsx(type, props, key)</code> / <code>jsxs</code> \u2014 compatible helpers used by TypeScript/JSX transforms.</li> <li><code>maniascriptFragment(text?)</code> \u2014 returns an XML comment containing the supplied text: <code>&lt;!-- text --&gt;</code>. Useful to inject raw Maniascript into <code>&lt;script&gt;</code> nodes.</li> </ul>"},{"location":"devs/forge/#hooks-effects","title":"Hooks / Effects","text":"<ul> <li><code>setScript(effect: () =&gt; string | (() =&gt; void), deps?: any[])</code></li> <li>Registers a body-level effect; the <code>effect</code> is called during the commit phase.</li> <li>If <code>effect()</code> returns a <code>string</code>, it is treated as Maniascript code and appended to the body scripts.</li> <li> <p>If it returns a <code>function</code>, that function is stored as the cleanup for that hook.</p> </li> <li> <p><code>setScriptHeader(effect: () =&gt; string | (() =&gt; void), deps?: any[])</code></p> </li> <li> <p>Works like <code>setScript</code> but its returned string will be added to the header area (above <code>main()</code>), for helper functions or global declarations.</p> </li> <li> <p>Hooks are deduplicated by dependency comparison and the system keeps <code>cleanup</code> functions for teardown when needed.</p> </li> </ul>"},{"location":"devs/forge/#component-registry","title":"Component registry","text":"<ul> <li><code>registerComponent(name, comp)</code> \u2014 override or register a component for runtime customization (used by plugins to replace components).</li> <li><code>unregisterComponent(name)</code> \u2014 remove registration</li> <li><code>getComponent(name, fallback)</code> \u2014 resolve a component by name, falling back to the <code>fallback</code> implementation.</li> <li><code>getRegisteredComponents()</code> \u2014 debugging helper to inspect current registrations.</li> </ul>"},{"location":"devs/forge/#rendering-helpers","title":"Rendering helpers","text":"<ul> <li><code>renderJsx(element)</code> \u2014 convert a virtual element to Manialink XML string (handles strings, arrays, components and attributes).</li> <li><code>render(element, rootId?, obj?)</code> \u2014 render the element into a full manialink XML (used for testing or non-UI contexts). When <code>obj</code> is provided it is attached as <code>dataObj</code> for <code>getProperties()</code> access.</li> </ul>"},{"location":"devs/forge/#utility-functions","title":"Utility functions","text":"<ul> <li><code>getProperties()</code> \u2014 returns the <code>objMap</code> attached to the current render root (used to access <code>data</code> passed into a Manialink).</li> <li><code>disposeScript(rootId)</code> \u2014 runs all cleanup functions for the given root and removes the root from memory.</li> </ul>"},{"location":"devs/forge/#api-reference","title":"API reference","text":""},{"location":"devs/forge/#types","title":"Types","text":"<ul> <li><code>Properties</code> \u2014 object describing properties passed to components (commonly includes <code>colors</code> and arbitrary keys).</li> <li><code>Hook</code> \u2014 internal type describing registered hooks for header/body effects.</li> </ul>"},{"location":"devs/forge/#functions","title":"Functions","text":"<ul> <li><code>createElement(tagName: string, props: any, ...children: any[]): object</code></li> <li> <p>Create a plain element object used by the renderer.</p> </li> <li> <p><code>Fragment(props: { children: any[] }) : any[]</code></p> </li> <li> <p>Simple passthrough container returning <code>props.children</code>.</p> </li> <li> <p><code>jsx(type: string|function, props: any, key?: string)</code> / <code>jsxs(...)</code></p> </li> <li> <p>Helpers compatible with TS/JSX transforms that call <code>createElement</code>.</p> </li> <li> <p><code>maniascriptFragment(text?: string) : string</code></p> </li> <li> <p>Wrap text in an XML comment so it is emitted verbatim inside a <code>&lt;script&gt;</code> node.</p> </li> <li> <p><code>registerComponent(name: string, comp: any) : void</code></p> </li> <li><code>unregisterComponent(name: string) : void</code></li> <li><code>getComponent&lt;T&gt;(name: string, fallback: T) : T</code></li> <li> <p><code>getRegisteredComponents() : Map&lt;string, any&gt;</code></p> </li> <li> <p><code>setScript(effect: () =&gt; string | (() =&gt; void), deps?: any[]) : void</code></p> </li> <li> <p>Register a body-level effect which either returns a Maniascript string or a cleanup function. When dependencies change, the effect runs again.</p> </li> <li> <p><code>setScriptHeader(effect: () =&gt; string | (() =&gt; void), deps?: any[]) : void</code></p> </li> <li> <p>Register a header-level effect (same semantics as <code>setScript</code>).</p> </li> <li> <p><code>getProperties() : objMap</code></p> </li> <li> <p>Returns the <code>dataObj</code> attached to the current render root (commonly accessed as <code>const props = getProperties();</code>).</p> </li> <li> <p><code>disposeScript(rootId = 'default') : void</code></p> </li> <li> <p>Run all cleanup functions for the hooks on the given root and remove the root.</p> </li> <li> <p><code>render(element:any, rootId?: string, obj?: objMap) : string</code></p> </li> <li> <p>High-level render function (returns a full <code>&lt;manialink&gt;</code> string; primarily for testing or non-Manialink use).</p> </li> <li> <p><code>renderJsx(element:any) : string</code></p> </li> <li>Core renderer converting virtual elements to Manialink XML.</li> </ul>"},{"location":"devs/forge/#globals","title":"Globals","text":"<ul> <li><code>roots : Map&lt;string, { hooks: Hook[]; dataObj?: objMap }&gt;</code> \u2014 map of render roots (useful for debugging during development).</li> </ul>"},{"location":"devs/forge/#examples","title":"Examples","text":""},{"location":"devs/forge/#simple-component-with-maniascript-injection","title":"Simple component with Maniascript injection","text":"<pre><code>import { createElement as h, maniascriptFragment, getProperties } from '@core/ui/forge';\n\nexport default function Updater() {\n  const props = getProperties();\n  const data = props.data;\n\n  return (\n    &lt;script&gt;\n      {maniascriptFragment(`\n        main() {\n          declare Text Data_PlayerNames for This;\n          Data_PlayerNames = \"\"\"${JSON.stringify(data.playerjson)}\"\"\";\n        }\n      `)}\n    &lt;/script&gt;\n  );\n}\n</code></pre>"},{"location":"devs/forge/#using-setscript-to-provide-script-body","title":"Using <code>setScript</code> to provide script body","text":"<pre><code>setScript(() =&gt; {\n  // Return a Maniascript string appended to the manialink's body\n  return `\n    // body script\n    Void _tick() {\n      // do something\n    }\n  `;\n}, [someDependency]);\n</code></pre>"},{"location":"devs/forge/#providing-header-helpers","title":"Providing header helpers","text":"<pre><code>setScriptHeader(() =&gt; {\n  return `\n  declare Text[] MyHelper for This;\n  Void _helper() {\n    // ...\n  }\n  `;\n});\n</code></pre>"},{"location":"devs/forge/#real-world-examples-in-this-repo","title":"Real-world examples in this repo","text":"<ul> <li><code>userdata/plugins/ulol/scoretable/ui/updater.tsx</code> \u2014 uses <code>getProperties()</code> and <code>maniascriptFragment</code> to inject JSON data into a <code>&lt;script&gt;</code> node.</li> <li><code>userdata/plugins/rmt/ui/overrideGreeting.tsx</code> \u2014 demonstrates <code>registerComponent</code> to override a component and <code>setScript()</code> to register script body code.</li> </ul> <p>Example: <code>overrideGreeting.tsx</code> <pre><code>import { createElement, setScript, registerComponent } from '@core/ui/forge';\n\nfunction Greeting({ name }) {\n  setScript(() =&gt; {\n    return `console.log('Overridden Greeting for ${name}');`;\n  }, [name]);\n\n  return &lt;label text={`Overridden: ${name}`} /&gt;;\n}\n\nregisterComponent('Greeting', Greeting);\n</code></pre></p>"},{"location":"devs/forge/#best-practices-tips","title":"Best practices &amp; tips \ud83d\udca1","text":"<ul> <li>Alias <code>createElement</code> when you prefer a shorter helper (<code>h</code>, <code>el</code>, or domain-specific <code>manialink</code>).</li> <li>Use <code>maniascriptFragment</code> to safely inject script blocks inside <code>&lt;script&gt;</code> elements.</li> <li>Only call <code>setScript</code> / <code>setScriptHeader</code> during render; avoid side-effects outside hooks.</li> <li>Use <code>registerComponent</code> to allow plugins to override components without modifying upstream code.</li> </ul>"},{"location":"devs/forge/#contributing-naming-conventions","title":"Contributing &amp; naming conventions","text":"<ul> <li>Prefer consistent aliases across the repo. Examples:</li> <li><code>import { createElement as h } from '@core/ui/forge';</code> (compact &amp; idiomatic)</li> <li><code>import { createElement as manialink } from '@core/ui/forge';</code> (domain-specific clarity)</li> <li><code>import * as ui2 from '@core/ui/forge';</code> (namespaced access when many helpers are needed)</li> <li>Keep aliases short in files with high JSX usage (<code>h</code>, <code>el</code>) and explicit in library code (<code>createElement</code>, <code>manialink</code>).</li> <li>Add a short note in <code>CONTRIBUTING.md</code> or <code>documentation/devs/</code> if you plan to standardize names across the project.</li> </ul> <p>For full runtime details, see the source: <code>core/ui/forge.ts</code>.}</p>"},{"location":"devs/plugins/","title":"Plugins","text":"<p>Back to Concept</p>"},{"location":"devs/plugins/#plugins","title":"Plugins","text":""},{"location":"devs/plugins/#table-of-contents","title":"Table of contents","text":"<ul> <li>Plugin manifest.json (0.12+)</li> <li>Basic Structure</li> <li>Manifest Schema</li> <li>Required Fields</li> <li>Optional Fields</li> <li>Dependency Management</li> <li>Declaring Dependencies</li> <li>Semver Range Examples</li> <li>Dependency Resolution Algorithm</li> <li>Load Order Example</li> <li>Fallback Resolution</li> <li>Game Compatibility</li> <li>MINIcontrol Version Compatibility</li> <li>Plugin Discovery and the PLUGINS Environment Variable</li> <li>Creating a New Plugin with Manifest</li> <li>Create Plugin Directory Structure</li> <li>Write Your manifest.json</li> <li>Implement Your Plugin</li> <li>Test Plugin Loading</li> <li>Verify in Runtime</li> <li>Troubleshooting</li> <li>Plugin Not Loading</li> <li>Dependency Resolution Failures</li> <li>Game Compatibility Issues</li> <li>Version Range Debugging</li> <li>Helper methods introduced in 0.12</li> <li>addListener</li> <li>removeListener</li> <li>addCommand</li> <li>addSetting</li> <li>removeSetting</li> <li>addColor</li> <li>removeColor</li> <li>destroy</li> <li>Chat commands</li> <li>Listeners</li> <li>Interacting with the dedicated server</li> <li>Sending chat messages</li> <li>Write to stdout / log file</li> </ul>"},{"location":"devs/plugins/#plugin-manifestjson-012","title":"Plugin manifest.json (0.12+)","text":"<p>Starting with MINIcontrol 0.12, every plugin must include a <code>manifest.json</code> file in its root directory. The manifest system enables:</p> <ul> <li>Semantic versioning with automatic compatibility checking</li> <li>Dependency management with deterministic resolution</li> <li>Game compatibility declarations (TmForever, Trackmania 2020, etc.)</li> <li>Topological loading ensuring dependencies load before dependents</li> </ul>"},{"location":"devs/plugins/#basic-structure","title":"Basic Structure","text":"<p>Every plugin must have a <code>manifest.json</code> at its root:</p> <pre><code>core/plugins/myplugin/\n  \u251c\u2500\u2500 manifest.json\n  \u2514\u2500\u2500 index.ts\n</code></pre>"},{"location":"devs/plugins/#manifest-schema","title":"Manifest Schema","text":"<pre><code>{\n  \"id\": \"myplugin\",\n  \"name\": \"My Plugin\",\n  \"description\": \"Optional description of what the plugin does\",\n  \"authors\": \"Your Name\",\n  \"date\": \"2025-12-10\",\n  \"version\": \"1.0.0\",\n  \"requiresMinicontrolVersion\": \"^0.12.0\",\n  \"requiresGame\": \"Trackmania\",\n  \"depends\": [\n    { \"id\": \"database\", \"range\": \"^1.0.0\" },\n    { \"id\": \"menu\", \"range\": \"&gt;=1.2.0 &lt;2.0.0\", \"optional\": false }\n  ]\n}\n</code></pre>"},{"location":"devs/plugins/#required-fields","title":"Required Fields","text":"Field Type Description <code>id</code> string Unique plugin identifier (use folder path for nested plugins, e.g., <code>widgets/records</code>) <code>name</code> string Human-readable plugin name <code>version</code> string Plugin version following semantic versioning (e.g., <code>1.2.3</code>) <code>requiresMinicontrolVersion</code> string Semver range of compatible MINIcontrol versions (e.g., <code>^0.12.0</code>) <code>date</code> string ISO date (YYYY-MM-DD) or datetime when the plugin was last updated"},{"location":"devs/plugins/#optional-fields","title":"Optional Fields","text":"Field Type Description <code>description</code> string Brief description of the plugin's functionality <code>authors</code> string Plugin author(s) name(s) <code>requiresGame</code> string | null Target game: <code>\"Trackmania\"</code>, <code>\"Maniplanet\"</code>, <code>\"TmForever\"</code>, or <code>null</code> for any <code>depends</code> array List of plugin dependencies (see Dependency Management below)"},{"location":"devs/plugins/#dependency-management","title":"Dependency Management","text":""},{"location":"devs/plugins/#declaring-dependencies","title":"Declaring Dependencies","text":"<p>Dependencies are specified in the <code>depends</code> array. Each dependency must include:</p> <pre><code>{\n  \"id\": \"database\",\n  \"range\": \"^1.0.0\",\n  \"optional\": false\n}\n</code></pre> Field Type Required Description <code>id</code> string Yes Plugin ID of the dependency <code>range</code> string Yes Semver range specifying compatible versions <code>optional</code> boolean No If <code>true</code>, plugin loads even if dependency is missing (default: <code>false</code>)"},{"location":"devs/plugins/#semver-range-examples","title":"Semver Range Examples","text":"<p>MINIcontrol uses standard semantic versioning ranges:</p> Range Matches Description <code>^1.0.0</code> <code>&gt;=1.0.0 &lt;2.0.0</code> Compatible with 1.x (caret range) <code>~1.2.3</code> <code>&gt;=1.2.3 &lt;1.3.0</code> Compatible with 1.2.x (tilde range) <code>&gt;=1.0.0 &lt;2.0.0</code> 1.0.0 to 1.9.9 Explicit range <code>*</code> any version Any version (use sparingly!) <code>1.2.3</code> exactly 1.2.3 Exact version match <p>Best practice: Use caret ranges (<code>^1.0.0</code>) for most dependencies to allow backward-compatible updates.</p>"},{"location":"devs/plugins/#dependency-resolution-algorithm","title":"Dependency Resolution Algorithm","text":"<p>MINIcontrol uses a sophisticated resolver to compute the optimal plugin load order:</p> <ol> <li>Discovery: Scans <code>core/plugins</code> and <code>userdata/plugins</code> for all available plugins</li> <li>Validation: Validates each <code>manifest.json</code> against the schema</li> <li>Compatibility Check: Filters out plugins incompatible with the current game or MINIcontrol version</li> <li>Version Selection: For each required plugin, picks the highest compatible version</li> <li>Dependency Graph: Builds a directed acyclic graph (DAG) of dependencies</li> <li>Topological Sort: Orders plugins so dependencies always load before dependents</li> <li>Cycle Detection: Fails fast if circular dependencies are detected</li> </ol>"},{"location":"devs/plugins/#load-order-example","title":"Load Order Example","text":"<p>Given these manifests:</p> <p>records/manifest.json: <pre><code>{\n  \"id\": \"records\",\n  \"version\": \"1.0.0\",\n  \"depends\": [\n    { \"id\": \"database\", \"range\": \"^1.0.0\" }\n  ]\n}\n</code></pre></p> <p>widgets/records/manifest.json: <pre><code>{\n  \"id\": \"widgets/records\",\n  \"version\": \"1.0.0\",\n  \"depends\": [\n    { \"id\": \"records\", \"range\": \"^1.0.0\" },\n    { \"id\": \"widgets\", \"range\": \"^1.0.0\" }\n  ]\n}\n</code></pre></p> <p>The resolver will load in this order: 1. <code>database</code> (no dependencies) 2. <code>records</code> (depends on database) 3. <code>widgets</code> (no dependencies) 4. <code>widgets/records</code> (depends on records and widgets)</p>"},{"location":"devs/plugins/#fallback-resolution","title":"Fallback Resolution","text":"<p>If the strict resolver fails (due to version conflicts or missing dependencies), MINIcontrol falls back to a more lenient algorithm:</p> <ol> <li>Attempts to load plugins in discovery order</li> <li>Skips plugins with unmet dependencies</li> <li>Logs warnings for each skipped plugin</li> <li>Continues loading remaining plugins</li> </ol> <p>This fallback ensures the server starts even with dependency issues, though some plugins may not load.</p>"},{"location":"devs/plugins/#game-compatibility","title":"Game Compatibility","text":"<p>The <code>requiresGame</code> field declares which Trackmania title(s) your plugin supports:</p> <pre><code>{\n  \"requiresGame\": \"TmForever\"\n}\n</code></pre> <p>Valid values: - <code>\"TmForever\"</code> - TrackMania Forever / Nations / United - <code>\"Trackmania\"</code> - Trackmania 2020 / Trackmania\u00b2 - <code>\"Maniplanet\"</code> - ManiaPlanet titles - <code>null</code> - Works with any game (default if field is omitted)</p> <p>How it works: - During discovery, MINIcontrol checks the current game against each plugin's <code>requiresGame</code> - Incompatible plugins are automatically excluded from the load list - This prevents runtime errors from game-specific API calls</p> <p>Example - TmForever-only plugin: <pre><code>{\n  \"id\": \"tmnf/dedimania\",\n  \"requiresGame\": \"TmForever\",\n  \"requiresMinicontrolVersion\": \"^0.12.0\"\n}\n</code></pre></p>"},{"location":"devs/plugins/#minicontrol-version-compatibility","title":"MINIcontrol Version Compatibility","text":"<p>The <code>requiresMinicontrolVersion</code> field ensures your plugin only loads on compatible controller versions:</p> <pre><code>{\n  \"requiresMinicontrolVersion\": \"^0.12.0\"\n}\n</code></pre> <p>Common patterns: - <code>^0.12.0</code> - Compatible with 0.12.x (recommended for new plugins) - <code>&gt;=0.11.0 &lt;1.0.0</code> - Works with 0.11+ but not yet tested with 1.0 - <code>*</code> - Any version (risky! Only use if truly compatible with any version)</p> <p>How it's checked: - MINIcontrol compares its own version against the range - Incompatible plugins are excluded during discovery - Prevents crashes from API changes between versions</p>"},{"location":"devs/plugins/#plugin-discovery-and-the-plugins-environment-variable","title":"Plugin Discovery and the PLUGINS Environment Variable","text":"<p>By default, MINIcontrol discovers and attempts to load all compatible plugins from: - <code>core/plugins/</code> (built-in plugins) - <code>userdata/plugins/</code> (custom/third-party plugins)</p>"},{"location":"devs/plugins/#restricting-plugin-loading","title":"Restricting Plugin Loading","text":"<p>Set the <code>PLUGINS</code> environment variable to control which plugins load:</p> <pre><code># Load only specific plugins\nPLUGINS=\"database,records,menu,admin\"\n\n# Use wildcards for nested plugins\nPLUGINS=\"kacky,kacky/*,widgets/records,admin\"\n\n# Leave empty to auto-load all compatible plugins\nPLUGINS=\"\"\n</code></pre> <p>Wildcard patterns: - <code>kacky/*</code> matches <code>kacky/foo</code>, <code>kacky/bar/baz</code>, etc. - <code>widgets/*</code> matches any plugin under <code>widgets/</code> - <code>*</code> matches everything (same as empty)</p> <p>Important: When using <code>PLUGINS</code> as a whitelist, you must explicitly include dependencies:</p> <pre><code># \u274c Wrong - widgets/records won't load (missing dependencies)\nPLUGINS=\"widgets/records\"\n\n# \u2705 Correct - includes all dependencies\nPLUGINS=\"database,records,widgets,widgets/records\"\n</code></pre>"},{"location":"devs/plugins/#creating-a-new-plugin-with-manifest","title":"Creating a New Plugin with Manifest","text":""},{"location":"devs/plugins/#1-create-plugin-directory-structure","title":"1. Create Plugin Directory Structure","text":"<pre><code>userdata/plugins/myplugin/\n  \u251c\u2500\u2500 manifest.json\n  \u2514\u2500\u2500 index.ts\n</code></pre>"},{"location":"devs/plugins/#2-write-your-manifestjson","title":"2. Write Your manifest.json","text":"<pre><code>{\n  \"id\": \"myplugin\",\n  \"name\": \"My Plugin\",\n  \"description\": \"Does something useful\",\n  \"authors\": \"Your Name\",\n  \"date\": \"2025-12-10\",\n  \"version\": \"1.0.0\",\n  \"requiresMinicontrolVersion\": \"^0.12.0\",\n  \"requiresGame\": null,\n  \"depends\": []\n}\n</code></pre>"},{"location":"devs/plugins/#3-implement-your-plugin","title":"3. Implement Your Plugin","text":"<pre><code>import Plugin from '@core/plugins';\n\nexport default class MyPlugin extends Plugin {\n    async onLoad() {\n        this.addListener(\"TMC.PlayerConnect\", this.onConnect, this);\n        this.addCommand(\"/mycommand\", this.handleCommand, \"My command\");\n    }\n\n    async onConnect(player: any) {\n        tmc.chat(`Welcome ${player.nickname}!`, player.login);\n    }\n\n    async handleCommand(login: string, args: string[]) {\n        tmc.chat(\"Command executed!\", login);\n    }\n}\n</code></pre>"},{"location":"devs/plugins/#4-test-plugin-loading","title":"4. Test Plugin Loading","text":"<pre><code># Check if plugin is discovered\ntsx plugins.ts list\n\n# Verify load order\ntsx plugins.ts order\n\n# Start MINIcontrol\nnpm start\n</code></pre>"},{"location":"devs/plugins/#5-verify-in-runtime","title":"5. Verify in Runtime","text":"<p>Use admin commands to manage your plugin: <pre><code>//plugins              # Plugin manager\n//plugin list          # See all loaded plugins\n//plugin reload myplugin  # Reload after changes\n//plugin unload myplugin  # Unload plugin\n//plugin load myplugin    # Load plugin\n</code></pre></p>"},{"location":"devs/plugins/#troubleshooting","title":"Troubleshooting","text":""},{"location":"devs/plugins/#plugin-not-loading","title":"Plugin Not Loading","text":"<p>Check manifest validation: <pre><code>tsx plugins.ts list\n</code></pre></p> <p>Common issues: - Missing required fields (<code>id</code>, <code>name</code>, <code>version</code>, etc.) - Invalid semver in <code>version</code> or <code>requiresMinicontrolVersion</code> - Invalid date format (use YYYY-MM-DD) - Circular dependencies in <code>depends</code> array</p>"},{"location":"devs/plugins/#dependency-resolution-failures","title":"Dependency Resolution Failures","text":"<p>View resolver output: <pre><code>tsx plugins.ts order\n</code></pre></p> <p>Console logs show: - \"Plugin X missing dependency Y\" - Add Y to your environment or its manifest - \"Version conflict\" - Adjust semver ranges to be more permissive - \"Circular dependency detected\" - Refactor plugin architecture to remove cycles</p>"},{"location":"devs/plugins/#game-compatibility-issues","title":"Game Compatibility Issues","text":"<p>If plugin doesn't load on TmForever but works on TM2020: - Check <code>requiresGame</code> in manifest - Verify API calls are game-agnostic or conditionally executed - Use <code>tmc.game.Name</code> to detect current game and branch logic</p>"},{"location":"devs/plugins/#version-range-debugging","title":"Version Range Debugging","text":"<p>Test semver ranges in Node.js REPL: <pre><code>const semver = require('semver');\nsemver.satisfies('1.2.3', '^1.0.0');  // true\nsemver.satisfies('2.0.0', '^1.0.0');  // false\n</code></pre></p>"},{"location":"devs/plugins/#helper-methods-introduced-in-012","title":"Helper methods introduced in 0.12","text":"<p>MINIcontrol 0.12+ provides convenient helper methods in the base <code>Plugin</code> class that automatically track registrations for proper cleanup when your plugin is unloaded. Using these helpers ensures your plugin doesn't leak memory or leave dangling references.</p>"},{"location":"devs/plugins/#addlistener-server-event-listeners","title":"addListener() - Server Event Listeners","text":"<p>Register server callbacks with automatic cleanup tracking. Use this instead of <code>tmc.server.addListener()</code> directly.</p> <pre><code>// In your plugin's onLoad() method:\nthis.addListener(\"TMC.PlayerConnect\", this.onPlayerConnect, this);\nthis.addListener(\"Trackmania.BeginMap\", this.onBeginMap, this);\n</code></pre> <p>Benefits: - Automatically tracked for cleanup when plugin unloads - No need to manually call <code>removeListener()</code> in <code>onUnload()</code> - Prevents memory leaks from forgotten listener removals</p>"},{"location":"devs/plugins/#removelistener-manual-listener-removal","title":"removeListener() - Manual Listener Removal","text":"<p>Explicitly remove a tracked listener before plugin unload (optional, as <code>destroy()</code> handles this automatically).</p> <pre><code>this.removeListener(\"TMC.PlayerConnect\", this.onPlayerConnect);\n</code></pre>"},{"location":"devs/plugins/#addcommand-chat-commands","title":"addCommand() - Chat Commands","text":"<p>Register chat commands with automatic cleanup. Replaces direct <code>tmc.addCommand()</code> calls.</p> <pre><code>this.addCommand(\"/mycommand\", this.handleCommand, \"Command description\");\nthis.addCommand(\"//admincommand\", this.handleAdminCommand, \"Admin command\");\n</code></pre> <p>Features: - Automatically binds callback to plugin instance (no need for <code>.bind(this)</code>) - Tracked for cleanup on plugin unload - Third parameter is the help text shown in <code>/help</code></p>"},{"location":"devs/plugins/#addsetting-plugin-settings","title":"addSetting() - Plugin Settings","text":"<p>Register plugin settings with automatic cleanup and optional change callbacks.</p> <pre><code>// Simple setting\nthis.addSetting(\"myplugin.enabled\", true, null, \"Enable my plugin feature\");\n\n// Setting with change callback\nthis.addSetting(\"myplugin.maxPlayers\", 100, this.onMaxPlayersChanged, \"Maximum players\");\n\n// In your plugin:\nasync onMaxPlayersChanged(newValue: number, oldValue: number, key: string) {\n    tmc.cli(`Setting ${key} changed from ${oldValue} to ${newValue}`);\n}\n</code></pre> <p>Parameters: - <code>name</code>: Setting key (use <code>pluginname.settingname</code> convention) - <code>defaultValue</code>: Default value (any type) - <code>callback</code>: Optional callback when setting changes (automatically bound to plugin instance) - <code>description</code>: Human-readable description</p>"},{"location":"devs/plugins/#removesetting-manual-setting-removal","title":"removeSetting() - Manual Setting Removal","text":"<p>Explicitly unregister a setting (optional, handled by <code>destroy()</code>).</p> <pre><code>this.removeSetting(\"myplugin.enabled\");\n</code></pre>"},{"location":"devs/plugins/#ui-components-manialink-custom-tags","title":"UI Components (Manialink custom tags)","text":"<p>Components let you register handlers that expand custom tags into Manialink markup and optional page script.</p> <ul> <li>Handlers implement the <code>ComponentFunction</code> signature: <code>(attrs, inner, obj) =&gt; { replacement, script? } | Promise&lt;...&gt;</code></li> <li>Obj hold all values from the manialink itself: like: <code>obj.colors</code>,<code>obj.data</code>, <code>obj.actions</code></li> <li>Custom components should always start with capital letter.</li> </ul> <p>Example handler (Mybutton):</p> <pre><code>// plugin code\nthis.addComponent(\"Mybutton\", async (attrs, inner, obj) =&gt; {\n  const replacement = `&lt;frame pos=\"...\"&gt;&lt;label text=\"${attrs.label || inner}\" /&gt;&lt;/frame&gt;`;\n  const script = `// ManiaScript for mouse events or animations`;\n  return { replacement, script };\n});\n</code></pre> <p>Notes: - Handlers are registered with <code>tmc.ui.registerComponentHandler</code> (plugins should use <code>plugin.addComponent</code>). - Tag names are matched case-insensitively. - Returned <code>script</code> fragments are concatenated into the final page script. Be careful to avoid duplicate global symbol names. - For syntax highlighting of embedded scripts/templates in VS Code: prefer a tagged template (e.g. <code>html</code>`...`<code>) or install an extension like</code>es6-string-html<code>. For ManiaScript you can also use a comment hint (e.g.</code>/ ManiaScript /`) before the template and use an extension that supports language injection.</p>"},{"location":"devs/plugins/#addcolor-color-settings","title":"addColor() - Color Settings","text":"<p>Register theme color settings with automatic cleanup.</p> <pre><code>// Simple color\nthis.addColor(\"myplugin.highlight\", \"f07\", null, \"Highlight color\");\n\n// Color with change callback\nthis.addColor(\"myplugin.background\", \"123\", this.onColorChanged, \"Background color\");\n\nasync onColorChanged(newValue: string, oldValue: string, key: string) {\n    // Update UI with new color\n    await this.refreshWidgets();\n}\n</code></pre> <p>Benefits: - Colors are automatically available in templates via <code>tmc.settings.colors</code> - Respects user's theme customization - Can be changed via admin settings interface</p>"},{"location":"devs/plugins/#removecolor-manual-color-removal","title":"removeColor() - Manual Color Removal","text":"<p>Explicitly unregister a color setting.</p> <pre><code>this.removeColor(\"myplugin.highlight\");\n</code></pre>"},{"location":"devs/plugins/#destroy-automatic-cleanup","title":"destroy() - Automatic Cleanup","text":"<p>Called automatically when plugin is unloaded. You typically don't call this directly, but it's important to understand what it does:</p> <p>Cleanup actions: 1. Removes all tracked server listeners 2. Unregisters all chat commands 3. Unregisters all settings 4. Unregisters all color settings 5. Destroys any Manialink instances 6. Nulls out plugin fields to allow garbage collection</p> <p>Important: If you override <code>onUnload()</code>, you don't need to manually clean up resources registered via helper methods \u2014 <code>destroy()</code> handles this automatically.</p>"},{"location":"devs/plugins/#migration-from-old-pattern","title":"Migration from old pattern","text":"<p>Before (0.11 and earlier): <pre><code>async onLoad() {\n    tmc.server.addListener(\"TMC.PlayerConnect\", this.onConnect, this);\n    tmc.addCommand(\"/mycommand\", this.handleCmd.bind(this), \"Help\");\n    tmc.settings.register(\"myplugin.enabled\", true, this.onEnabledChanged.bind(this), \"Enable\");\n}\n\nasync onUnload() {\n    // Easy to forget these!\n    tmc.server.removeListener(\"TMC.PlayerConnect\", this.onConnect);\n    tmc.removeCommand(\"/mycommand\");\n    tmc.settings.unregister(\"myplugin.enabled\");\n}\n</code></pre></p> <p>After (0.12+): <pre><code>async onLoad() {\n    this.addListener(\"TMC.PlayerConnect\", this.onConnect, this);\n    this.addCommand(\"/mycommand\", this.handleCmd, \"Help\");\n    this.addSetting(\"myplugin.enabled\", true, this.onEnabledChanged, \"Enable\");\n}\n\nasync onUnload() {\n    // Nothing needed! Cleanup is automatic via destroy()\n}\n</code></pre></p>"},{"location":"devs/plugins/#best-practices","title":"Best Practices","text":"<ol> <li>Use helpers consistently: Always prefer <code>this.addListener()</code>, <code>this.addCommand()</code>, etc. over direct <code>tmc.*</code> calls</li> <li>Let destroy() handle cleanup: Don't manually remove registered items in <code>onUnload()</code> unless you have a specific reason</li> <li>Name settings properly: Use <code>pluginname.settingname</code> convention to avoid conflicts</li> <li>Bind callbacks automatically: Helper methods handle binding, so avoid <code>.bind(this)</code> in your calls</li> <li>Test unload/reload: Use <code>//plugin reload &lt;name&gt;</code> to verify your plugin cleans up properly</li> </ol>"},{"location":"devs/plugins/#chat-commands","title":"Chat commands","text":"<pre><code>this.addCommand(\"/mycommand\", this.myCommand, \"description\");\n</code></pre>"},{"location":"devs/plugins/#listeners","title":"Listeners","text":"<p>To make plugins work across all generations of Trackmania games, we took some creative liberties to make our lives easier.</p> <ul> <li>Callbacks starting with: <code>TrackMania.</code> and  <code>ManiaPlanet.</code> are all renamed to start with <code>Trackmania.</code>.</li> <li>All script callbacks will be redirected as events.</li> </ul> <p>Also note that there's a few <code>TMC.events</code> that should be used instead of the native dedicated server callbacks. These are writen as adapters so they'll provide the right info from each game in the same way, even if the game's underlying data differs.</p> <pre><code>// async onPlayerConnect(player: Player) {}\nthis.addListener(\"TMC.PlayerConnect\", this.onPlayerConnect, this)\n\n// async onPlayerDisconnect(player: Player) {}\nthis.addListener(\"TMC.PlayerDisconnect\", this.onPlayerDisconnect, this)\n\n// async onPlayerCheckpoint(login:string, racetime:int, checkpointinrace:int) {}\nthis.addListener(\"TMC.PlayerCheckpoint\", this.onPlayerCheckpoint, this);\n\n// async onPlayerFinish(login:string, time:int) {}\nthis.addListener(\"TMC.PlayerFinish\", this.finish, this);\n\n// async onPlayerGiveup(login:string) {}\nthis.addListener(\"TMC.PlayerGiveup\", this.giveup, this);\n\n//  onVoteCancel(data: VoteStruct) {}\nthis.addListener(\"TMC.Vote.Cancel\", this.voteCancel, this);\n\n//  onVoteDeny(data: VoteStruct) {}\nthis.addListener(\"TMC.Vote.Deny\", this.voteDeny, this);\n\n//  onVotePass(data: VoteStruct) {}\nthis.addListener(\"TMC.Vote.Pass\", this.votePass, this);\n\n// generic ones use this callbacks\nthis.addListener(\"Trackmania.*\", this.callback, this);\n</code></pre>"},{"location":"devs/plugins/#interacting-with-the-dedicated-server","title":"Interacting with the dedicated server","text":"<p>To interact with the dedicated server, you usually subscribe to Dedicated Server callbacks and act upon them. You have 3 options in MINIcontrol:</p> <pre><code>// Execute an XML-RPC API call and receive the server response\nconst answer = await tmc.server.call(\"method\", ...params);\n// Execute an XML-RPC API call but ignore the server response\ntmc.server.send(\"method\", ...params);\n// Execute an XML-RPC API multicall, containing several XML-RPC API methods\nconst answers:any[] = await tmc.server.multicall([\n    [\"method\", ...params],\n    [\"method2\", ...params],\n    [\"method3\", ...params]\n    ]);\n</code></pre> <p>You can also override methods if needed...</p> <pre><code>tmc.server.addOverride(\"method\", this.myOverride.bind(this));\n</code></pre> <p>In case you need to call the original GBX method, use</p> <pre><code>async myOverride(data: any) {\n    await tmc.server.gbx.call(\"method\", ...params);\n}\n</code></pre>"},{"location":"devs/plugins/#sending-chat-messages","title":"Sending chat messages","text":"<p>Sending public and private chat messages.</p> <pre><code>// For sending chat messages, await is not needed.\ntmc.chat(`Hello World!`);\n\n// To send chat messages to specific players, provide a (comma-separated list or array of) login(s) as second parameter\ntmc.chat(`Hello World!`, \"login\")\ntmc.chat(`Hello World!`, \"login1, login2, ...\")\ntmc.chat(`Hello World!`, [\"login1\", \"login2\"])\n</code></pre>"},{"location":"devs/plugins/#write-to-stdout-log-file","title":"Write to stdout / log file","text":"<pre><code>// To log a message to stdout/log file, TM colors will be parsed to ansi sequences\ntmc.cli(\"trackmania color coded string\");\n// To log a debug message, shows only when debug is enabled in `.env`\ntmc.debug(\"trackmania color coded string\");\n</code></pre>"},{"location":"devs/quickstart-plugin/","title":"Quickstart plugin","text":"<p>Back to Concept</p>"},{"location":"devs/quickstart-plugin/#quickstart-creating-a-plugin-for-minicontrol","title":"Quickstart: Creating a plugin for MINIcontrol","text":"<p>This guide shows the minimal steps required to create, install and test a simple plugin using the MINIcontrol framework.</p>"},{"location":"devs/quickstart-plugin/#steps","title":"Steps","text":"<ol> <li>Create a plugin folder (recommended under <code>userdata/plugins/</code> for development):</li> </ol> <pre><code>mkdir -p userdata/plugins/example-plugin\n</code></pre> <ol> <li>Create <code>manifest.json</code> in the plugin folder. Minimal manifest:</li> </ol> <pre><code>{\n    \"id\": \"example-plugin\",\n    \"name\": \"Example Plugin\",\n    \"version\": \"0.1.0\",\n    \"requiresMinicontrolVersion\": \"^0.12.0\",\n    \"date\": \"2025-12-10\"\n}\n</code></pre> <ol> <li>Create an <code>index.ts</code> file that exports a default class extending <code>Plugin</code> (found at <code>core/plugins/index.ts</code>). Example skeleton:</li> </ol> <pre><code>import Plugin from '@core/plugins';\n\nexport default class ExamplePlugin extends Plugin {\n    async onLoad() {\n        // Register listeners and commands here\n        this.addListener('TMC.PlayerConnect', this.onPlayerConnect, this);\n    }\n\n    async onStart() {\n        // Called after MiniControl is fully started\n    }\n\n    async onUnload() {\n        // Cleanup resources here\n    }\n\n    async onPlayerConnect(player: any) {\n        tmc.chat(`Welcome ${player.nickname}!`);\n    }\n}\n</code></pre> <ol> <li>Install the plugin (copying folder into <code>userdata/plugins</code>) if you're developing outside the runtime (PluginLoader will validate manifest):</li> </ol> <pre><code>const loader = new PluginLoader();\nawait loader.install('path/to/your/local/plugin');\n</code></pre> <ol> <li> <p>Test the plugin features</p> </li> <li> <p>Use chat commands you registered</p> </li> <li>Click widget UI elements</li> <li>Check logs and manifest validation messages if the plugin did not load</li> </ol>"},{"location":"devs/quickstart-plugin/#tips-troubleshooting","title":"Tips &amp; Troubleshooting","text":"<ul> <li>Use <code>import.meta.dirname</code> to ensure Twing template resolution finds your templates.</li> <li>If MiniControl refuses to load your plugin, check the <code>requiresMinicontrolVersion</code> range in <code>manifest.json</code> and your installed <code>tmc.version</code>.</li> <li>Use <code>tmc.cli()</code> and <code>tmc.debug()</code> to write helpful debug messages.</li> <li>If the loader reports missing dependencies, ensure dependent plugins are present and satisfy semver ranges.</li> </ul>"},{"location":"devs/quickstart-plugin/#example","title":"Example","text":"<p>You can find a complete minimal example plugin in the repo under <code>documentation/devs/example-plugin</code></p> <p>Happy hacking! \ud83c\udf89</p>"},{"location":"devs/ui-system/","title":"ui2 \u2014 JSX-style UI primitives &amp; Manialink integration \ud83c\udfae","text":"<p>Location: <code>core/ui/*</code> (notably <code>manialink.ts</code> and <code>forge.ts</code>)</p>"},{"location":"devs/ui-system/#overview","title":"Overview","text":"<p><code>ui2</code> is the lightweight UI layer used by MINIcontrol for building Manialink-based interfaces using JSX-style components and a small runtime that collects Maniascript from components.</p> <p>Key pieces: - <code>Manialink</code> class \u2014 manages manialink lifecycle (render, display, hide, destroy) and integrates with the <code>forge</code> renderer to produce final XML. - <code>forge</code> (see <code>forge.md</code>) \u2014 provides JSX helpers, hooks, and render utilities.</p>"},{"location":"devs/ui-system/#manialink-class-quick-reference","title":"Manialink class (quick reference)","text":"<pre><code>import Manialink from '@core/ui/manialink';\n\nconst widget = new Manialink(() =&gt; &lt;frame&gt;...&lt;/frame&gt;);\nawait widget.display();\nawait widget.hide();\nawait widget.destroy();\n</code></pre>"},{"location":"devs/ui-system/#important-methods-props","title":"Important methods &amp; props","text":"<ul> <li><code>id</code> \u2014 unique autogenerated id; useful for debugging</li> <li><code>display()</code> \u2014 show the manialink (first display triggers <code>tmc.ui.displayManialink</code>)</li> <li><code>hide()</code> \u2014 hide it from players</li> <li><code>destroy(hide = true)</code> \u2014 teardown and ask UI manager to remove references</li> <li><code>render()</code> \u2014 produces the manialink XML (internal; uses <code>renderJsx</code> and runs hook commit phases)</li> <li><code>cleanReferences()</code> \u2014 runs <code>disposeScript</code> and clears fields for GC</li> </ul>"},{"location":"devs/ui-system/#how-rendering-works-high-level","title":"How rendering works (high-level)","text":"<ol> <li><code>Manialink.render()</code> creates/gets a <code>root</code> object storing <code>hooks</code> and <code>dataObj</code>.</li> <li>It sets the current root (so <code>getProperties()</code> works) and calls the component function to produce a virtual element tree.</li> <li><code>renderJsx()</code> converts the tree to XML and returns it.</li> <li><code>render()</code> then commits effects: runs header effects first (collected via <code>setScriptHeader</code>), then body effects (via <code>setScript</code>).</li> <li>Headers and scripts are deduplicated and combined into a single <code>&lt;script&gt;</code> block inside the manialink.</li> </ol>"},{"location":"devs/ui-system/#example-creating-a-live-updating-widget","title":"Example: Creating a live-updating widget","text":"<pre><code>// userdata/plugins/example-plugin/ui/mywidget.tsx\nimport { createElement as h, maniascriptFragment, setScript, getProperties } from '@core/ui/forge';\nimport Manialink from '@core/ui/manialink';\n\nfunction WidgetContent() {\n  const props = getProperties();\n\n  // Register periodic script only when a dependency changes\n  setScript(() =&gt; {\n    return `\n    main() {\n      // This code will be merged into the manialink script body\n      while(True) {\n        // perform updates\n        yield;\n      }\n    }\n    `;\n  }, [JSON.stringify(props.data)]);\n\n  return (\n    &lt;frame&gt;\n      &lt;label text=\"Widget active\" /&gt;\n      &lt;script&gt;{maniascriptFragment(`// inline script for small snippets`)}&lt;/script&gt;\n    &lt;/frame&gt;\n  );\n}\n\n// Create and show\nconst ml = new Manialink(() =&gt; &lt;WidgetContent /&gt;);\nawait ml.display();\n</code></pre>"},{"location":"devs/ui-system/#integration-plugin-notes","title":"Integration &amp; plugin notes","text":"<ul> <li><code>dataObj</code> attached to the root can be used to pass per-manialink data (accessible via <code>getProperties()</code> in components).</li> <li>To allow plugin-based customizations, register component overrides using <code>registerComponent(name, comp)</code>.</li> <li>Clean up with <code>disposeScript()</code> and <code>manialink.destroy()</code> to ensure no lingering cleanup references remain.</li> </ul>"},{"location":"devs/ui-system/#debugging-tips","title":"Debugging tips","text":"<ul> <li>Inspect <code>roots</code> from <code>forge.ts</code> during runtime to see active roots and their <code>hooks</code>.</li> <li>Use <code>getRegisteredComponents()</code> to review overrides.</li> <li>Use <code>maniascriptFragment()</code> to ensure injected snippets are preserved in output.</li> </ul> <p>See <code>documentation/devs/forge.md</code> for full API details and examples for the hook system.</p>"},{"location":"devs/class/","title":"Index","text":"<p>Back to Concept</p>"},{"location":"devs/class/#core-classes-index","title":"Core classes (index)","text":"<p>This page lists the main core classes and modules in MINIcontrol and links to the complete reference documentation for each.</p> <ul> <li>Server \u2014 Low-level API for communicating with the game server and handling callbacks (GBX transport wrapper).</li> <li>MapManager \u2014 Manage maps, map states and map-related operations.</li> <li>PlayerManager \u2014 Manage player state, lookups, and events.</li> <li>UIManager \u2014 UI helper and Manialink management utilities.</li> <li>CommandManager \u2014 Chat commands registration and handling.</li> <li>SettingsManager \u2014 Configuration manager for plugin and server settings.</li> <li>Database \u2014 Database connection, migrations, models and sync helpers.</li> <li>BillManager \u2014 Billing and economy helper (if enabled).</li> <li>Menu \u2014 In-memory menu registry used by widgets and plugins.</li> <li>Plugins \u2014 Plugin base class, loader, resolver and manifest details.</li> <li>GBX Client \u2014 The GBXRemote / XML-RPC transport client.</li> <li>Utils \u2014 Utility and helper functions used across the codebase.</li> <li>Log \u2014 Logging wrapper and console output helpers.</li> <li>Sentry \u2014 Error reporting and Sentry integration.</li> <li>MiniControl (tmc) \u2014 The global runtime API with plugin lifecycle, command helpers and server access.</li> </ul> <p>If you don't find the class you're looking for, search the <code>core/</code> folder or ask on the project repo.</p>"},{"location":"devs/class/billmanager/","title":"Billmanager","text":"<p>Back to Concept</p>"},{"location":"devs/class/billmanager/#bill-manager","title":"Bill manager","text":"<p>The <code>BillManager</code> provides a simple cross-game abstraction for the server's in\u2011game currency systems. It is designed to support both Maniaplanet and TMForever via unified callbacks &amp; helpers.</p> <p>What you can do with the Bill Manager: - Create a billing transaction (SendBill, Donate, Pay) - Attach callbacks for lifecycle events (issued, paid, refused, error) - Send the bill / transaction to the game for processing</p> <p>Location: <code>core/billmanager.ts</code></p>"},{"location":"devs/class/billmanager/#overview","title":"Overview","text":"<p><code>BillManager</code> wraps a <code>BillState</code> object which stores transaction metadata and user-facing callbacks. It tracks created <code>BillState</code> objects until they complete and will invoke callbacks when <code>Trackmania.BillUpdated</code> events are received from the server.</p> <p>Key features: - Cross-game support for coin/planet/copper transactions - Event-driven callback model for transaction lifecycle - Built-in validation (admin checks, minimum amount)</p>"},{"location":"devs/class/billmanager/#important-notes","title":"Important notes","text":"<ul> <li>Admin checks: <code>Pay</code> and <code>SendBill</code> actions are only allowed when the <code>issuerLogin</code> is in <code>tmc.admins</code>.</li> <li>Minimum amount: Any transaction less than 10 units will throw an error when creating a transaction.</li> <li>Donate uses the <code>SendBill</code> method internally (alias)</li> <li>Game-specific methods: <code>getIngameCurrency()</code> calls <code>GetServerPlanets</code> on ManiaPlanet and <code>GetServerCoppers</code> on TmForever.</li> </ul>"},{"location":"devs/class/billmanager/#api","title":"API","text":""},{"location":"devs/class/billmanager/#billstate-per-transaction-object","title":"BillState (per-transaction object)","text":"<p>Properties: - <code>issuerLogin</code> - login who issues the transaction (admin usually) - <code>loginFrom</code> - login of player the bill is about - <code>loginTo</code> - optional recipient (defaults to server login) - <code>method</code> - <code>SendBill</code> | <code>Donate</code> | <code>Pay</code> - <code>amount</code> - numeric amount - <code>message</code> - message shown to player - <code>transactionId</code> - filled later when transaction is created/updated - <code>billId</code> - created by the server - <code>stateName</code> - latest state name</p> <p>Callbacks (assign to the <code>BillState</code> instance): - <code>onIssued?: (bill: BillState) =&gt; Promise&lt;void&gt;</code> \u2014 invoked when the bill reaches <code>Issued</code> state - <code>onPayed?: (bill: BillState) =&gt; Promise&lt;void&gt;</code> \u2014 invoked when the bill reaches <code>Payed</code> state (transaction complete) - <code>onRefused?: (bill: BillState) =&gt; Promise&lt;void&gt;</code> \u2014 invoked when the bill was refused by player - <code>onError?: (bill: BillState) =&gt; Promise&lt;void&gt;</code> \u2014 invoked on errors</p> <p>Methods: - <code>async send()</code> \u2014 Sends the transaction to the server (calls server's <code>SendBill</code>/<code>Pay</code>). Returns when <code>SendBill</code>/<code>Pay</code> call has returned a <code>billId</code>.</p>"},{"location":"devs/class/billmanager/#billmanager","title":"BillManager","text":"<p>Properties: - <code>billStates: BillState[]</code> \u2014 in-memory list of tracked transactions</p> <p>Methods: - <code>createTransaction(type, issuerLogin, loginFrom, amount, message): BillState</code> \u2014 Create a transaction and register it for state tracking. May throw on invalid inputs or permission checks. - <code>getIngameCurrency()</code> \u2014 Query for server currency (Coppers/Planets) depending on the game</p> <p>Events and internal handling: - <code>onBillUpdated(data)</code> \u2014 internal listener (registered for <code>Trackmania.BillUpdated</code>) that maps the server state to the corresponding bill and calls the lifecycle callbacks above.</p>"},{"location":"devs/class/billmanager/#example-usage","title":"Example usage","text":"<pre><code>// Create bill, note: 'SendBill', 'Donate', 'Pay' are valid method values\nconst bill = tmc.billMgr.createTransaction(\n    'SendBill',\n    issuerLogin, // typically admin\n    targetLogin, // who receives the bill (loginFrom)\n    100,         // amount\n    `You were billed 100 coppers by an admin. Do you want to pay this bill?`,\n);\n\n// Register lifecycle callbacks\nbill.onIssued = async (b) =&gt; {\n    const from = await tmc.getPlayer(b.loginFrom);\n    const issuer = await tmc.getPlayer(b.issuerLogin);\n    tmc.chat(`\u00a4info\u00a4${issuer.nickname} issued a bill of \u00a4white\u00a4${b.amount} \u00a4info\u00a4to \u00a4white\u00a4${from.nickname}`);\n};\n\nbill.onPayed = async (b) =&gt; {\n    tmc.chat(`\u00a4info\u00a4Bill ${b.billId} was paid successfully.`);\n};\n\nbill.onRefused = async (b) =&gt; {\n    const from = await tmc.getPlayer(b.loginFrom);\n    tmc.chat(`\u00a4info\u00a4${from.nickname} refused to pay the bill.`);\n};\n\nbill.onError = async (b) =&gt; {\n    tmc.chat(`\u00a4error\u00a4Transaction failed: ${b.stateName}`, b.issuerLogin);\n};\n\n// Send the bill\nawait bill.send();\n</code></pre>"},{"location":"devs/class/billmanager/#handling-pay-transactions","title":"Handling <code>Pay</code> transactions","text":"<p><code>Pay</code> is used to trigger secure payments (items / subscription). Only admins can issue <code>Pay</code> transactions. Attempting to <code>createTransaction('Pay', ...)</code> with a non-admin <code>issuerLogin</code> will throw.</p>"},{"location":"devs/class/billmanager/#using-donate","title":"Using <code>Donate</code>","text":"<p><code>Donate</code> is an alias of <code>SendBill</code> and will result in the same server method being called; use it for semantic clarity.</p>"},{"location":"devs/class/billmanager/#how-onbillupdated-maps-server-events-to-callbacks","title":"How <code>onBillUpdated</code> maps server events to callbacks","text":"<p>The BillManager listens to <code>Trackmania.BillUpdated</code> (only for TmForever/ManiaPlanet) and examines <code>StateName</code> to decide which callback to call: - <code>Issued</code> \u2192 <code>onIssued</code> - <code>Payed</code> \u2192 <code>onPayed</code> (and the bill is removed from tracking) - <code>Refused</code> \u2192 <code>onRefused</code> (and the bill is removed from tracking) - <code>error</code> \u2192 <code>onError</code> (and the bill is removed from tracking)</p> <p>Unknown states are logged. The manager also supports internal handling for fallback states and a <code>TransactionId</code> update.</p>"},{"location":"devs/class/billmanager/#additional-helper-getingamecurrency","title":"Additional helper: getIngameCurrency()","text":"<p>Call <code>tmc.billMgr.getIngameCurrency()</code> to query the server's currency type and amount. Internally this maps the call to: - <code>GetServerPlanets</code> on ManiaPlanet - <code>GetServerCoppers</code> on TmForever</p>"},{"location":"devs/class/billmanager/#best-practices","title":"Best practices","text":"<ul> <li>Always perform admin checks before creating <code>SendBill</code> and <code>Pay</code> transactions at plugin level \u2014 the API enforces this but logging or extra checks help debug.</li> <li>Attach <code>onError</code> callbacks to handle edge cases and to report issues to the issuer.</li> <li>If you expect players to refuse or partially pay, implement <code>onRefused</code> and <code>onPayed</code> to keep your plugin state in sync.</li> <li>Use <code>tmc.cli()</code> and <code>tmc.debug()</code> to capture transaction lifecycle for troubleshooting.</li> </ul>"},{"location":"devs/class/billmanager/#troubleshooting","title":"Troubleshooting","text":"<ul> <li>If <code>createTransaction()</code> throws:<ul> <li>Confirm the issuer is an admin for <code>SendBill</code>/<code>Pay</code> cases</li> <li>Confirm <code>amount &gt;= 10</code> (minimum enforced)</li> </ul> </li> <li>If callbacks are not fired:<ul> <li>Verify the server emits <code>Trackmania.BillUpdated</code> (older/newer games differ), and <code>tmc.game.Name</code> is one the manager supports.</li> <li>Confirm your <code>BillState</code> has a valid <code>billId</code> after <code>send()</code> \u2014 inspect debug logs.</li> </ul> </li> </ul>"},{"location":"devs/class/billmanager/#example-donate","title":"Example (Donate)","text":"<pre><code>const bill = tmc.billMgr.createTransaction('Donate', issuerLogin, targetLogin, 50, \"Thanks for your help!\");\nbill.onIssued = async (b) =&gt; tmc.chat(`Thank you for your donation!`);\nawait bill.send();\n</code></pre>"},{"location":"devs/class/chatcmd/","title":"Chatcmd","text":"<p>Back to Concept</p>"},{"location":"devs/class/chatcmd/#chat-command-manager-commandmanager","title":"Chat Command Manager (CommandManager)","text":"<p><code>CommandManager</code> (available at <code>tmc.chatCmd</code>) is the central registry for in-game chat commands and their handlers. It is used by core, built-in, and third-party plugins to expose chat commands to players and admins.</p>"},{"location":"devs/class/chatcmd/#table-of-contents","title":"Table of contents","text":"<ul> <li>Overview</li> <li>API</li> <li>Registering commands</li> <li>Built-in commands</li> <li>Execution &amp; parsing</li> <li>Admin commands &amp; permissions</li> <li>Using <code>tmc.chatCmd.execute</code> programmatically</li> <li>Examples</li> <li>Best practices</li> </ul>"},{"location":"devs/class/chatcmd/#overview","title":"Overview","text":"<p>The <code>CommandManager</code> maps command triggers (single-slash <code>/</code> or double-slash <code>//</code>) to asynchronous callback functions. Commands are matched case-insensitively at the beginning of the chat message. When a command is found, the arguments are parsed (supports quoted strings) and the command's callback is invoked:</p> <pre><code>callback(login: string, args: string[]): Promise&lt;void&gt;\n</code></pre> <p>Use <code>tmc.addCommand()</code> (shortcut) or <code>tmc.chatCmd.addCommand()</code> to register commands. Plugin authors should use the helper <code>this.addCommand()</code> from the plugin base class to ensure the command is automatically cleaned up on <code>onUnload()</code>.</p>"},{"location":"devs/class/chatcmd/#api","title":"API","text":"<pre><code>class CommandManager {\n  addCommand(command: string, callback: CallableCommand, help?: string, admin?: boolean);\n  removeCommand(command: string): void;\n  async execute(login: string, text: string): Promise&lt;void&gt;;\n}\n</code></pre> <p>The <code>callable</code> callback signature is:</p> <pre><code>type CallableCommand = (login: string, args: string[]) =&gt; Promise&lt;void&gt;;\n</code></pre>"},{"location":"devs/class/chatcmd/#registering-commands","title":"Registering commands","text":"<ul> <li><code>command</code>: the trigger text you want to match, e.g. <code>/help</code>, <code>//kick</code>, <code>/records</code>.</li> <li><code>callback</code>: the async function invoked when the command is executed.</li> <li><code>help</code>: optional help text shown in UIs (used by <code>/help</code>/<code>//help</code>).</li> <li><code>admin</code> (optional): boolean to force marking the command as admin-only. By default the manager treats commands that start with <code>//</code> as admin commands.</li> </ul> <p>Examples:</p> <pre><code>// Simple public command\ntmc.addCommand('/hello', async (login, args) =&gt; {\n  await tmc.chat(`Hello ${login}!`);\n}, 'Say hello');\n\n// Admin command (use double-slash or set admin flag)\ntmc.addCommand('//kick', async (login, args) =&gt; {\n  const target = args[0];\n  await tmc.server.call('Kick', target);\n}, 'Kick a player');\n</code></pre> <p>Plugin authors should prefer the plugin base helper to register commands that are removed automatically on plugin destroy:</p> <pre><code>this.addCommand('/mycmd', this.onMyCmd.bind(this), 'Do something');\n</code></pre>"},{"location":"devs/class/chatcmd/#built-in-commands","title":"Built-in commands","text":"<p>The CommandManager registers a set of built-in commands during initialization. Notable commands include:</p> <ul> <li><code>/help</code> \u2014 shows non-admin commands in a <code>ListWindow</code> (searchable with UI)</li> <li><code>//help</code> \u2014 shows admin commands</li> <li><code>/version</code> \u2014 displays server/controller version</li> <li><code>//plugins</code> \u2014 shows plugin manager window</li> <li><code>//plugin</code> \u2014 manage plugins (<code>list</code>, <code>load</code>, <code>unload</code>, <code>reload</code>) \u2014 admin only</li> <li><code>//admin</code> \u2014 manage admins (list, add, remove) \u2014 admin only</li> <li><code>//call</code> \u2014 call a server API method (useful for debugging) \u2014 admin only</li> <li><code>//shutdown</code> \u2014 stop the controller \u2014 admin only</li> </ul> <p>These are examples; your runtime might have additional built-in commands.</p>"},{"location":"devs/class/chatcmd/#execution-parsing","title":"Execution &amp; parsing","text":"<p>Commands are matched only if the incoming chat text starts with <code>/</code> (the manager returns early if not). Matching logic:</p> <ul> <li>The manager iterates through registered commands and checks if the input text starts with the command trigger (case-insensitive).</li> <li>Commands support both single and double slash triggers; double slash forms are usually for admin commands.</li> <li>The manager supports quoted arguments. For example:</li> </ul> <pre><code>/say \"this is a quoted string\" one two\n</code></pre> <p>will parse into args: <code>['this is a quoted string', 'one', 'two']</code></p> <p>Parsing notes: - Double-quoted strings support escaped quotes - Numeric and boolean parsing is left to the command handler; the manager delivers raw string args</p> <p>When a command is executed, the manager passes <code>login</code> and <code>args</code> to the callback function and awaits completion.</p> <p>If no command matches, the user gets a <code>Command not found</code> message.</p>"},{"location":"devs/class/chatcmd/#admin-commands-permissions","title":"Admin commands &amp; permissions","text":"<p>Two places affect admin enforcement:</p> <ol> <li>The input prefix \u2014 commands executed with <code>//</code> are treated as admin commands: if the player is not in <code>tmc.admins</code> (list of admin logins), the manager refuses execution and sends <code>Not allowed</code>.</li> <li>Commands registered with <code>admin</code> flag or with <code>//</code> prefix are considered admin-only for UIs. For best practice, register admin-only commands with <code>//</code> triggers to ensure enforcement and UI segregation.</li> </ol> <p>Note: There is a subtlety \u2014 the manager enforces admin permissions based on the incoming slash prefix (<code>//</code>) rather than the command's <code>admin</code> flag. In practice, register admin commands with <code>//</code> and avoid registering public commands with admin flag alone.</p>"},{"location":"devs/class/chatcmd/#using-tmcchatcmdexecute-programmatically","title":"Using <code>tmc.chatCmd.execute</code> programmatically","text":"<p>You can programmatically execute a command as a particular user or as server by calling <code>tmc.chatCmd.execute(login, text)</code>; for example:</p> <pre><code>await tmc.chatCmd.execute('playerLogin', '/ex-hello arg1 arg2');\n</code></pre> <p>This is commonly used to execute commands from UI actions, plugin logic, or tests.</p>"},{"location":"devs/class/chatcmd/#examples","title":"Examples","text":""},{"location":"devs/class/chatcmd/#simple-command","title":"Simple command","text":"<pre><code>tmc.addCommand('/time', async (login) =&gt; {\n  const map = tmc.maps.currentMap;\n  await tmc.chat(`Current map: ${map.Name}`, login);\n}, 'Show current map');\n</code></pre>"},{"location":"devs/class/chatcmd/#command-with-arguments","title":"Command with arguments","text":"<pre><code>tmc.addCommand('/msg', async (login, args) =&gt; {\n  const target = args[0];\n  const text = args.slice(1).join(' ');\n  await tmc.chat(text, target);\n}, 'Send a private message');\n</code></pre>"},{"location":"devs/class/chatcmd/#command-with-quoted-argument","title":"Command with quoted argument","text":"<pre><code>// Player: /say \"Hello everyone, this is a test\"\n// args = ['Hello everyone, this is a test']\n</code></pre>"},{"location":"devs/class/chatcmd/#registering-commands-from-plugins","title":"Registering commands from plugins","text":"<p>In a plugin extending the Project <code>Plugin</code> base class, prefer <code>this.addCommand()</code> so the plugin deregisters commands during <code>onUnload()</code>:</p> <pre><code>export default class MyPlugin extends Plugin {\n  async onLoad() {\n    this.addCommand('/records', this.cmdRecords.bind(this), 'List records');\n  }\n  async onUnload() {\n    // Commands added via the plugin helper are removed automagically on destroy()\n  }\n}\n</code></pre>"},{"location":"devs/class/chatcmd/#admin-commands","title":"Admin commands","text":"<p>When registering a command that should be admin-only, use <code>//</code> trigger or mark <code>admin=true</code> (but prefer <code>//</code>):</p> <pre><code>this.addCommand('//restart', async (login, args) =&gt; {\n  await tmc.server.call('RestartMap');\n}, 'Restart the map (admin)');\n</code></pre>"},{"location":"devs/class/chatcmd/#best-practices","title":"Best practices","text":"<ul> <li>Use <code>this.addCommand()</code> in plugins (it auto-registers and cleans up on <code>destroy()</code>)</li> <li>Use simple, consistent command triggers (short names) and provide clear <code>help</code> text</li> <li>Make admin commands start with <code>//</code> and use <code>tmc.admins</code> for permission checks where needed</li> <li>Prefer quoting for multi-word arguments and use argument parsing within your callback for complex semantics</li> <li>Use <code>tmc.chatCmd.execute()</code> to run commands from UIs rather than duplicating logic</li> </ul>"},{"location":"devs/class/chatcmd/#chatcommand-manager","title":"ChatCommand manager","text":"<pre><code>class CommandManager {\n\n    /**\n     * adds command to the command manager\n     * @param command command to add\n     * @param callback callack function\n     * @param help help text\n     * @param admin force admin\n     */\n    addCommand(command: string, callback: CallableFunction, help: string = \"\", admin: boolean | undefined = undefined);\n\n    // remove command\n    removeCommand(command: string);\n\n    // excute a command\n    async execute(login, text);\n}\n</code></pre>"},{"location":"devs/class/database/","title":"Database","text":"<p>The Database manager is responsible for connecting to the configured database, running migrations and exposing models and helpers for plugins.</p> <p>Key responsibilities:</p> <ul> <li>Connects via Sequelize (sequelize-typescript) and chooses driver based on the <code>DATABASE</code> environment variable (sqlite/mysql/postgres).</li> <li>Runs migrations using Umzug from <code>./core/migrations/*.ts</code>, <code>./userdata/migrations/*.ts</code>, and plugin provided migrations in <code>./userdata/plugins/**/migrations/*.ts</code>.</li> <li>Registers and exposes first-party models from <code>core/schemas/*</code> such as <code>map.model.ts</code> (<code>TmMap</code>) and <code>players.model.ts</code> (<code>Player</code>).</li> <li>Provides <code>addModels(models: ModelCtor[])</code> so plugins can register their own models so they are recognized by the running Sequelize instance.</li> <li>Listens for runtime events like <code>TMC.PlayerConnect</code>, <code>TMC.PlayerDisconnect</code> and <code>Trackmania.EndMap</code> to synchronize runtime state with the DB.</li> </ul> <p>Example usage for plugin authors:</p> <pre><code>import MyModel from './schemas/myplugin.model';\n\nclass MyPlugin extends Plugin {\n  async onLoad() {\n    // register model with the running Sequelize instance\n    tmc.database.addModels([MyModel]);\n  }\n}\n</code></pre> <p>Direct access to the Sequelize instance is available via <code>tmc.database.sequelize</code> when initialized. If you need to run raw queries or transactions, prefer using the Sequelize API and existing models to ensure compatibility.</p> <p>Recommended patterns:</p> <ul> <li>Use models exported from <code>core/schemas/*</code> to interact with core tables instead of direct SQL.</li> <li>Place per-plugin migrations under <code>userdata/plugins/&lt;id&gt;/migrations/*.ts</code> so they run automatically with the core migrations at startup.</li> <li>Avoid performing heavy synchronous operations in migrations or startup; keep them idempotent and reversible.</li> </ul>"},{"location":"devs/class/gbx/","title":"Gbx","text":"<p>Back to Concept</p>"},{"location":"devs/class/gbx/#gbx-client-gbxremote-xml-rpc","title":"GBX Client (GBXRemote / XML-RPC)","text":""},{"location":"devs/class/gbx/#table-of-contents","title":"Table of contents","text":"<ul> <li>Key responsibilities</li> <li>API</li> <li>Errors &amp; limits</li> <li>Best practices</li> <li>Example</li> <li>Implementation notes</li> <li>Events</li> </ul> <p><code>GbxClient</code> is a low-level transport adapter that implements the GBXRemote (XML-RPC) stream protocol used by Trackmania dedicated servers. It is used by the <code>Server</code> class to communicate with the game server for XML-RPC calls and receive callbacks.</p>"},{"location":"devs/class/gbx/#key-responsibilities","title":"Key responsibilities","text":"<ul> <li>Connect to the server via TCP</li> <li>Perform protocol handshake (<code>GBXRemote 2</code>)</li> <li>Serialize/deserialize XML-RPC method calls, method responses, and callbacks</li> <li>Offer <code>call</code>, <code>send</code>, <code>callScript</code>, <code>sendScript</code>, <code>multicall</code>, <code>multisend</code></li> <li>Buffering and chunk handling (partial messages)</li> <li>Convert legacy <code>TrackMania.</code> and <code>ManiaPlanet.</code> callback prefixes to <code>Trackmania.</code></li> <li>Expose simple metrics for debugging counters</li> </ul>"},{"location":"devs/class/gbx/#api","title":"API","text":"<pre><code>class GbxClient {\n    // connection\n    async connect(host?: string, port?: number): Promise&lt;boolean&gt;;\n    async disconnect(): Promise&lt;true&gt;;\n\n    // XML-RPC method calls (wait for a response)\n    async call(method: string, ...params: any): Promise&lt;any&gt;\n\n    // XML-RPC requests (fire-and-forget)\n    send(method: string, ...params: any): Promise&lt;void&gt;\n\n    // ModeScript calls\n    async callScript(method: string, ...args: any): Promise&lt;any&gt;\n    async sendScript(method: string, ...args: any): Promise&lt;any&gt;\n\n    // Pack multiple calls into a single request\n    async multicall(methods: Array&lt;any&gt;): Promise&lt;any[]&gt;\n    async multisend(methods: Array&lt;any&gt;): Promise&lt;void&gt;\n}\n</code></pre>"},{"location":"devs/class/gbx/#errors-limits","title":"Errors &amp; limits","text":"<ul> <li><code>call</code>/<code>send</code> will throw / log errors when the GBX transport is not connected</li> <li>Requests are validated against size limits; the limit depends on the running game (e.g., Trackmania has a 7 MB cap)</li> <li>When the transport is not connected, methods return <code>undefined</code> or reject</li> </ul>"},{"location":"devs/class/gbx/#best-practices","title":"Best practices","text":"<ul> <li>Use <code>Server.call</code> / <code>Server.send</code> (wrappers) instead of directly calling <code>GbxClient</code> unless you need low-level control.</li> <li>For scripts or plugin code that interacts with ModeScript, use <code>callScript</code> (await) or <code>sendScript</code> (fire-and-forget).</li> <li>Use <code>multicall</code>/<code>multisend</code> where you need to batch many XMLRPC calls for performance.</li> </ul>"},{"location":"devs/class/gbx/#example","title":"Example","text":"<pre><code>// Inside a plugin or core code\nawait tmc.server.call('Authenticate', user, pass);\nawait tmc.server.call('ChatSendServerMessage', 'Hello world');\n\n// Fire-and-forget\ntmc.server.send('SomeMethod', arg1, arg2);\n</code></pre>"},{"location":"devs/class/gbx/#implementation-notes","title":"Implementation notes","text":"<ul> <li><code>GbxClient</code> uses <code>xmlrpc/lib/serializer</code> and <code>xmlrpc/lib/deserializer</code> to process the XML-RPC payloads</li> <li>It keeps a <code>requestHandle</code> to match responses to their Promises</li> <li>The client supports optional counters (enabled with <code>DEBUG_GBX_COUNTERS=true</code>) to debug TX/RX rates and send counts</li> <li>Partial or large messages are handled with read headers and a buffer (<code>recvData</code>) \u2014 the module will only process complete messages</li> </ul>"},{"location":"devs/class/gbx/#events","title":"Events","text":"<ul> <li>The <code>Server</code> class listens to callbacks from <code>GbxClient</code>. Methods such as <code>Trackmania.Event.*</code> are forwarded to <code>Server</code> which in turn emits <code>TMC.*</code> events for plugin consumption.</li> </ul> <p>If you need a separate document to describe <code>Server</code>'s <code>onCallback</code> and how it maps to <code>TMC</code> events, see class/server.md.</p>"},{"location":"devs/class/log/","title":"Log","text":"<p>Back to Concept</p>"},{"location":"devs/class/log/#log-corelogts","title":"log (core/log.ts)","text":""},{"location":"devs/class/log/#table-of-contents","title":"Table of contents","text":"<ul> <li>API</li> <li>Behavior</li> <li>Usage examples</li> <li>Notes</li> </ul> <p>The <code>log</code> module provides a thin wrapper around Node console logging with: - Optional color parsing for Trackmania <code>$</code> color codes (and formatting shortcuts) - Optional filesystem logging for persistence</p>"},{"location":"devs/class/log/#api-default-instance","title":"API (default instance)","text":"<pre><code>import log from \"@core/log\";\nlog.debug(str); // Debug-level output\nlog.info(str);  // Informational output and file write\nlog.warn(str);  // Warnings\nlog.error(str); // Errors\n</code></pre>"},{"location":"devs/class/log/#behavior","title":"Behavior","text":"<ul> <li><code>Tm2Console()</code> converts <code>$</code> color and style codes from Trackmania formatting into ANSI sequences for console output based on <code>ANSILEVEL</code> environment variable.</li> <li><code>info()</code>, <code>warn()</code> and <code>error()</code> write to disk when <code>WRITELOG=true</code>. Files are written under <code>userdata/log/</code> with ISO date filenames: <code>YYYY-MM-DD_console.log</code>.</li> <li><code>debug()</code> messages are written to disk only when both <code>WRITELOG=true</code> and <code>DEBUG=true</code> (to avoid noisy logs).</li> <li>Each line in the log file is a standardized line of the format: <code>TIMESTAMP [LEVEL] MESSAGE</code> where <code>TIMESTAMP</code> is the UTC ISO timestamp and <code>LEVEL</code> is <code>INFO</code>, <code>WARN</code>, or <code>ERROR</code>.</li> <li><code>log</code> instantiates a per-process formatter based on <code>ANSILEVEL</code> at startup to avoid re-parsing format codes on every message (optimizes runtime performance).</li> <li>Hue mapping: when converting <code>$</code> color codes to 4-bit ANSI colors, MINIcontrol now uses centered 60\u00b0 sectors (0=red, 60=yellow, 120=green, 180=cyan, 240=blue, 300=magenta) to better approximate 4-bit ANSI colors. Saturation and lightness are used to detect desaturated/very-bright colors and map them to neutral greys or bright white.</li> <li>Hue mapping: when converting <code>$</code> color codes to 4-bit ANSI colors, MINIcontrol now uses centered 60\u00b0 sectors (0=red, 60=yellow, 120=green, 180=cyan, 240=blue, 300=magenta) to better approximate 4-bit ANSI colors. Saturation and perceived luminance are used to detect desaturated/very-bright colors and map them to neutral greys or bright white.<ul> <li>Desaturation threshold: <code>s &lt; 0.15</code> \u2014 treat as greyscale (map to white/black depending on luminance).</li> <li>Bright threshold: <code>luminance &gt;= 0.65</code> \u2014 use bright (ANSI prefix 9).</li> </ul> </li> <li>Very bright threshold: <code>luminance &gt;= 0.93</code> \u2014 map directly to bright white (ANSI 7 with prefix 9).</li> <li>Black threshold: <code>luminance &lt;= 0.12</code> \u2014 map to black (ANSI 0).</li> <li>Greyscale mid threshold for light gray: <code>luminance &lt;= 0.60</code> \u2014 map greys to light gray (ANSI 7) when desaturated.</li> </ul> <pre><code>import log from \"@core/log\";\nlog.info(\"Server started\");\nlog.debug(\"This will be printed if DEBUG env var is set\");\n</code></pre>"},{"location":"devs/class/log/#notes","title":"Notes","text":"<ul> <li>The console output is sanitized using <code>removeColors()</code> when <code>ansiLevel === 0</code> so logs remain readable. Use <code>ANSILEVEL</code> to adjust color fidelity.</li> </ul>"},{"location":"devs/class/maps/","title":"Maps","text":"<p>Back to Concept</p>"},{"location":"devs/class/maps/#maps-manager","title":"Maps manager","text":"<p>The <code>MapManager</code> keeps a local view of the server's map list and provides convenience helpers for common map operations. It also tracks the <code>previousMap</code>, <code>currentMap</code>, and <code>nextMap</code> \u2014 updated by server callbacks (BeginMap/BeginRound/MapListModified).</p>"},{"location":"devs/class/maps/#table-of-contents","title":"Table of contents","text":"<ul> <li>Map interface</li> <li>Core behavior</li> <li>API &amp; Methods</li> <li>Events &amp; lifecycle</li> <li>Examples</li> <li>Best practices</li> <li>Troubleshooting</li> </ul>"},{"location":"devs/class/maps/#map-interface","title":"Map interface","text":"<p>Below is a minimal shape of a <code>Map</code> object returned by the server. Actual map objects may carry more fields depending on the game and server settings (karma, vehicle, formatting, etc.).</p> <pre><code>export interface Map {\n    UId: string;\n    Name: string;\n    Author: string;\n    AuthorNickname?: string;\n    AuthorTime: number;\n    GoldTime: number;\n    SilverTime: number;\n    BronzeTime: number;\n    CopperPrize: number;\n    FileName: string;\n    Environnement: string;\n    Mood: string;\n    LapRace: boolean;\n    NbLaps: number;\n    NbCheckpoints: number;\n    Vehicle?: string; // available when local db or specific game\n    Karma?: { positive: number; negative: number; total: number };\n    [key: string]: any;\n}\n</code></pre>"},{"location":"devs/class/maps/#core-behavior","title":"Core behavior","text":"<ul> <li>The <code>MapManager</code> maintains an in-memory map index keyed by <code>UId</code>.</li> <li>On startup <code>MapManager.init()</code> will fetch <code>GetCurrentMapInfo</code>, <code>GetNextMapInfo</code> and run <code>syncMaplist()</code> which fetches the entire server maplist in chunks and resolves additional map details using <code>GetMapInfo</code> (or <code>GetChallengeInfo</code> for TmForever).</li> <li>The <code>syncMaplist()</code> method merges old map data with new map objects (preserving custom data if present).</li> <li><code>MapManager</code> listens to <code>Trackmania.MapListModified</code> and <code>Trackmania.BeginMap</code> to keep its data up-to-date with server changes.</li> </ul>"},{"location":"devs/class/maps/#api-methods","title":"API &amp; Methods","text":"<pre><code>class MapManager {\n    // Properties\n    previousMap: Map;\n    currentMap: Map;\n    nextMap: Map;\n\n    // Control &amp; lifecycle (internal)\n    init(): Promise&lt;void&gt; // hook used by core to register listeners and sync data\n    afterInit(): Promise&lt;void&gt;\n\n    // Map operations\n    syncMaplist(): Promise&lt;void&gt; // force a full maplist sync using GBX multicalls\n    addMap(map: Map): void\n    removeMap(mapUId: string): void\n\n    // Accessors\n    get(): Map[] // returns the current maplist\n    getMaplist(): Map[] // alias for get()\n    getUids(): string[]\n    getMapCount(): number\n    getMap(mapUid: string): Map | undefined\n\n    // Time helper\n    getTimeInfo(): { timePlayed: number; timeLeft: number; timeLimit: number }\n}\n</code></pre>"},{"location":"devs/class/maps/#gettimeinfo","title":"getTimeInfo()","text":"<p>Returns an estimate of the current map time: - <code>timePlayed</code>: seconds elapsed since the current round started (includes 3 second pre-race offset) - <code>timeLeft</code>: remaining seconds until the configured TA time limit - <code>timeLimit</code>: configured TA limit (from <code>tmc.storage['minicontrol.taTimeLimit']</code>, <code>TALIMIT</code> env var, or default 300s)</p>"},{"location":"devs/class/maps/#events-lifecycle","title":"Events &amp; lifecycle","text":"<p><code>MapManager</code> registers the following server callbacks: - <code>Trackmania.BeginMap</code>: updates <code>previousMap</code>, <code>currentMap</code>, and <code>nextMap</code> - <code>Trackmania.MapListModified</code>: triggers <code>syncMaplist()</code> when map list has changed - <code>Trackmania.BeginRound</code>: resets internal <code>startTime</code> used by <code>getTimeInfo()</code></p>"},{"location":"devs/class/maps/#how-maplist-synchronization-works","title":"How maplist synchronization works","text":"<ul> <li><code>syncMaplist()</code> calls <code>GetMapList</code> to fetch map filenames and then uses <code>GetMapInfo</code> (or <code>GetChallengeInfo</code> for TMForever) via <code>multicall</code> in chunks of 100 to improve performance.</li> <li>When a new map object is found, the manager preserves custom fields previously attached to a map UID (merges old data into the new map object).</li> </ul>"},{"location":"devs/class/maps/#examples","title":"Examples","text":""},{"location":"devs/class/maps/#basic-list-maps","title":"Basic: list maps","text":"<pre><code>// Display map count and UIDs\nconst maps = tmc.maps.get();\nconsole.log(`Map Count: ${tmc.maps.getMapCount()}`);\nfor (const map of maps) console.log(map.UId, map.Name);\n</code></pre>"},{"location":"devs/class/maps/#example-plugin-command-show-current-map-details","title":"Example plugin command: show current map details","text":"<pre><code>this.addCommand('/mapinfo', async (login: string) =&gt; {\n    const map = tmc.maps.currentMap;\n    if (!map) {\n        tmc.chat('No current map known', login);\n        return;\n    }\n    tmc.chat(`Map: ${map.Name} by ${map.Author} \u2014 ${map.FileName}`, login);\n});\n</code></pre>"},{"location":"devs/class/maps/#example-plugin-command-interactive-listwindow","title":"Example plugin command: interactive ListWindow","text":"<pre><code>this.addCommand('/maps', async (login: string) =&gt; {\n    const list = tmc.maps.get().map(m =&gt; ({ UId: m.UId, Name: m.Name }));\n    const window = new ListWindow(login);\n    window.title = 'Server Maps';\n    window.setColumns([{ key: 'UId', title: 'UID', width: 30 }, { key: 'Name', title: 'Name', width: 130 }]);\n    window.setItems(list);\n    window.setActions(['View']);\n    await window.display();\n});\n</code></pre>"},{"location":"devs/class/maps/#example-programmatically-add-or-remove-a-map","title":"Example: programmatically add or remove a map","text":"<pre><code>// Add map object (local index only)\ntmc.maps.addMap({ UId: 'local-uid', Name: 'Custom map', FileName: 'custom.Map.Gbx', ... });\n\n// Remove map\ntmc.maps.removeMap('local-uid');\n</code></pre>"},{"location":"devs/class/maps/#best-practices","title":"Best practices","text":"<ul> <li>Avoid mutating <code>Map</code> objects returned from <code>tmc.maps.get()</code> \u2014 if you need to attach plugin-specific metadata, keep a plugin-local map keyed by UId or use <code>tmc.maps.addMap()</code> to add custom entries.</li> <li>Use <code>syncMaplist()</code> when you need to ensure the maplist is fresh (e.g., after a plugin installed new map files).</li> <li>Use <code>tmc.server.multicall</code> style for large operations rather than many single requests.</li> <li>When presenting map lists in UI, use <code>getUids()</code> for efficient lookups and <code>get()</code> to fetch cached objects.</li> </ul>"},{"location":"devs/class/maps/#troubleshooting","title":"Troubleshooting","text":"<ul> <li><code>GetMapList</code> may fail or return an empty list if the server is not properly configured or the maps directory is unavailable; <code>syncMaplist()</code> will log CLI errors.</li> <li>If <code>currentMap</code> is undefined after startup, confirm the server responded to <code>GetCurrentMapInfo</code> \u2014 gameplay or API compatibility issues may cause missing data.</li> <li>If <code>getTimeInfo()</code> returns unexpected values, check <code>TALIMIT</code> env var or <code>tmc.storage['minicontrol.taTimeLimit']</code> override and ensure <code>onBeginRound</code> is firing correctly.</li> </ul>"},{"location":"devs/class/menu/","title":"Menu","text":"<p>Back to Concept</p>"},{"location":"devs/class/menu/#menu-class","title":"Menu class","text":""},{"location":"devs/class/menu/#table-of-contents","title":"Table of contents","text":"<ul> <li>API</li> <li>Examples</li> <li>Details &amp; behavior</li> </ul> <p>The <code>Menu</code> class provides a basic in-memory menu registry and is used by built-in plugins (and other plugins) to register menu items visible to players.</p> <p>Menu is implemented as a singleton and uses a simple item structure:</p> <pre><code>export interface Item {\n    title: string;\n    action: string; // could be a chat command string or custom action\n    icon?: string;\n    category: string;\n    admin?: boolean; // only visible to admins if true\n}\n</code></pre> <p>Core API</p> <pre><code>class Menu {\n    // Returns the singleton instance\n    public static getInstance(): Menu;\n\n    // Add an item to the menu\n    public addItem(item: Item): void;\n\n    // Remove a menu item by title\n    public removeItem(item: string): void;\n\n    // Remove an entire category\n    public removeCategory(category: string): void;\n\n    // Return items in a category; respects admin flag\n    public getItemsByCategory(category: string, login: string | undefined): Item[];\n\n    // Return all items\n    public getItems(): Item[];\n}\n</code></pre> <p>Examples</p> <p>Add a simple server action to the Menu and use it later in a widget:</p> <pre><code>// Registering a menu item\nMenu.getInstance().addItem({\n    category: \"Server\",\n    title: \"Show Help\",\n    action: \"/help\",\n});\n\n// Show a widget when the player clicks the menu button\nthis.menuButton = new Widget(\"menuButton.xml.twig\", import.meta.dirname);\nthis.menuButton.setOpenAction(this.toggleMenu.bind(this));\nawait this.menuButton.display();\n\n// In your widget's click handler you can send the chat command or open a window\nasync toggleMenu(login: string) {\n    await tmc.chatCmd.execute(login, \"/help\");\n}\n</code></pre> <p>Details &amp; behavior</p> <ul> <li><code>getItemsByCategory</code> filters by the <code>admin</code> flag and only returns admin items for admin users (based on <code>tmc.admins</code>).</li> <li>Items are sorted alphabetically by title and admin items are shown after non-admin items by default.</li> </ul> <p>Useful pattern: create a small helper plugin that adds frequently used commands and menu items at <code>onLoad</code> and removes them at <code>onUnload</code>.</p>"},{"location":"devs/class/minicontrol/","title":"Minicontrol","text":"<p>Back to Concept</p>"},{"location":"devs/class/minicontrol/#minicontrol-tmc-global-api","title":"MiniControl (tmc) - global API","text":"<p>This page documents the public methods exposed by the <code>tmc</code> global object (MiniControl instance). Plugins can use these helpers to interact with the server and runtime.</p>"},{"location":"devs/class/minicontrol/#public-methods","title":"Public methods","text":"<p>Use the <code>tmc</code> instance to call server methods, manage plugins, register chat commands, and interact with system components.</p> Method Signature Description Example <code>getPlayer</code> <code>async getPlayer(login: string): Promise&lt;Player&gt;</code> Fetch or return cached player object <code>const player = await tmc.getPlayer(login);</code> <code>addCommand</code> <code>addCommand(command: string, callback: CallableCommand, help?: string): void</code> Convenience wrapper to register chat commands <code>tmc.addCommand('/hello', async (login, args) =&gt; tmc.chat('hi', login));</code> <code>removeCommand</code> <code>removeCommand(command: string): void</code> Removes a command previously registered (by its trigger) <code>tmc.removeCommand('/hello');</code> <code>findPlugin</code> <code>findPlugin(id: string): string | null</code> Return plugin path for discovered plugin id <code>const path = tmc.findPlugin('example');</code> <code>discoverPlugins</code> <code>async discoverPlugins(): Promise&lt;discovery[]&gt;</code> Return list of discovered plugins on disk (manifests + metadata) <code>const list = await tmc.discoverPlugins();</code> <code>installPlugin</code> <code>async installPlugin(fromPath: string): Promise&lt;string&gt;</code> Copy a plugin folder into <code>userdata/plugins</code> (must include manifest) <code>const dst = await tmc.installPlugin('/tmp/plugin');</code> <code>removePlugin</code> <code>async removePlugin(id: string): Promise&lt;void&gt;</code> Remove installed plugin folder (must not be loaded) <code>await tmc.removePlugin('plugin-id');</code> <code>loadPlugin</code> <code>async loadPlugin(name: string): Promise&lt;void&gt;</code> Load plugin into runtime <code>await tmc.loadPlugin('example');</code> <code>unloadPlugin</code> <code>async unloadPlugin(name: string): Promise&lt;void&gt;</code> Unload plugin from runtime <code>await tmc.unloadPlugin('example');</code> <code>cli</code> <code>cli(object: any): void</code> Write a console log with color processing <code>tmc.cli('test')</code> <code>debug</code> <code>debug(object: any): void</code> Conditional debug log (if DEBUG env var set) <code>tmc.debug('debug info')</code> <code>chat</code> <code>chat(text: string, login?: string | string[] | undefined): void</code> Send a server chat message; pass login to DM single or multiple recipients <code>tmc.chat('Hello', ['player1', 'player2']);</code> <code>database</code> Database Exposes <code>sequelize</code>, <code>addModels()</code> and helper sync routines (if enabled) <code>tmc.database.addModels([MyModel])</code>"},{"location":"devs/class/minicontrol/#plugin-lifecycle-helpers","title":"Plugin lifecycle helpers","text":"<p>The API includes helpers for plugin lifecycle and discovery; preference is to use the <code>PluginLoader</code> where possible. The methods above are convenience wrappers used by many plugins.</p>"},{"location":"devs/class/minicontrol/#best-practices","title":"Best practices","text":"<ul> <li>Prefer <code>tmc.settings</code> and <code>tmc.maps</code> APIs rather than manipulating plugin internals directly.</li> <li>For actions that need to persist across server restarts use <code>tmc.settings</code> rather than <code>tmc.storage</code>.</li> <li>When calling server-side APIs prefer <code>await tmc.server.call(...)</code> so errors can be caught and logged.</li> </ul>"},{"location":"devs/class/minicontrol/#server-call-guidance","title":"Server call guidance","text":"<p>For direct interactions with the dedicated server use <code>tmc.server</code> methods. See the Server class for details. Quick guidance:</p> <ul> <li><code>tmc.server.call(...)</code> \u2014 Use when you need a response (blocking/awaitable), e.g. <code>GetCurrentMapInfo</code>.</li> <li><code>tmc.server.send(...)</code> \u2014 Use for fire-and-forget commands where you don't need the result, e.g. <code>SendDisplayManialinkPage</code>.</li> <li><code>tmc.server.multicall([...])</code> \u2014 Batch <code>call</code> requests to improve performance and reduce RPC round-trips.</li> <li><code>tmc.server.multisend([...])</code> \u2014 Batch <code>send</code> requests for fire-and-forget batches.</li> </ul> <p>Example: <pre><code>// Get a map (needs response)\nconst map = await tmc.server.call('GetMapInfo', 'example.Gbx');\n\n// Show a manialink without waiting\ntmc.server.send('SendDisplayManialinkPage', xml, 0, false);\n\n// Batch requests for multiple map infos\nconst calls = [['GetMapInfo', 'a.gbx'], ['GetMapInfo', 'b.gbx']];\nconst results = await tmc.server.multicall(calls);\n\n// Batch many sends\nawait tmc.server.multisend([['SendDisplayManialinkPage', xml, 0, false], ...]);\n</code></pre></p>"},{"location":"devs/class/minicontrol/#see-also","title":"See also","text":"<ul> <li>Plugin base &amp; loader</li> <li>Server class (detailed call/send/multicall docs)</li> <li>SettingsManager</li> </ul>"},{"location":"devs/class/playermanager/","title":"Playermanager","text":"<p>Back to Concept</p>"},{"location":"devs/class/playermanager/#playermanager-player-class","title":"PlayerManager (Player class)","text":"<p>This doc explains the <code>PlayerManager</code> and the <code>Player</code> class that is used throughout MINIcontrol to represent connected players, manage player state and expose helper methods.</p>"},{"location":"devs/class/playermanager/#table-of-contents","title":"Table of contents","text":"<ul> <li>Overview</li> <li>Player object</li> <li>PlayerManager API</li> <li>Events &amp; lifecycle</li> <li>Examples</li> <li>Best practices</li> <li>Troubleshooting</li> </ul>"},{"location":"devs/class/playermanager/#overview","title":"Overview","text":"<p><code>PlayerManager</code> maintains a live, in-memory map of players currently connected to the server. It registers server callbacks to keep the player state up to date and offers helper methods for plugin authors to fetch, query and enumerate player objects.</p> <p>Key responsibilities: - Track connected players and cache their detailed info - Provide accessors to fetch <code>Player</code> objects (<code>getPlayer</code>, <code>getAll</code>, <code>getAllLogins</code>) and search utilities (<code>getPlayerbyNick</code>) - Emit friendly events using <code>tmc.server.emit</code> such as <code>TMC.PlayerConnect</code> and <code>TMC.PlayerDisconnect</code> when players connect/disconnect - Keep objects in sync with <code>Trackmania.PlayerInfoChanged</code> and <code>Trackmania.BeginRound</code> events</p>"},{"location":"devs/class/playermanager/#player-object","title":"Player object","text":"<p>The <code>Player</code> class models the typical player structure returned by the server. Not all fields are present in every game or server, and the object may also contain additional properties depending on the game/API.</p> <p>Key fields: - <code>login</code> \u2014 Unique player login string - <code>nickname</code> \u2014 Display name - <code>customNick</code> \u2014 Optional custom nickname - <code>playerId</code> \u2014 Player ID as reported by server - <code>teamId</code> \u2014 Team id / slot - <code>path</code> \u2014 current path/zone/position - <code>language</code> \u2014 player's language setting - <code>clientVersion</code> \u2014 client's version string - <code>iPAddress</code> \u2014 player's IP - <code>isSpectator</code> \u2014 true if player is currently in spectator mode - <code>isAdmin</code> \u2014 computed by checking <code>login</code> against <code>tmc.admins</code> - <code>isReferee</code>, <code>isPodiumReady</code>, <code>isBroadcasting</code>, <code>isManagedByOtherServer</code>, <code>isServer</code>, <code>hasPlayerSlot</code>, <code>hasJoinedGame</code>, etc. \u2014 flags derived from <code>Flags</code> bit fields reported by the server - <code>ladderStats</code> &amp; <code>ladderRanking</code> \u2014 when available, ladder/ranking information - <code>avatar</code> \u2014 when present, avatar data with filename/checksum</p> <p>Helper methods available on the Player object: - <code>syncFromDetailedPlayerInfo(data: any)</code> \u2014 fill all fields from a full detailed player info object, apply sanitization for nickname and derive flags - <code>syncFromPlayerInfo(data: any)</code> \u2014 update basic fields from a short PlayerInfo object (used by PlayerInfoChanged) - <code>set(key, value)</code> \u2014 set a field on the object dynamically</p> <p>Notes about flags and specator handling: - <code>forcedSpectatorState</code>, <code>isReferee</code>, <code>isPodiumReady</code>, <code>isUsingStereoScopy</code>, <code>isManagedByOtherServer</code>, <code>isServer</code>, <code>hasPlayerSlot</code>, <code>isBroadcasting</code>, <code>hasJoinedGame</code> are all derived from the numeric <code>Flags</code> field in the server payload. This may vary by game platform and is calculated by reading specific digits in <code>Flags</code>. - <code>spectatorTarget</code> is extracted from <code>SpecatorStatus</code> by <code>Math.floor(data.SpecatorStatus / 10000)</code>.</p>"},{"location":"devs/class/playermanager/#playermanager-api","title":"PlayerManager API","text":"<pre><code>class PlayerManager {\n  // Accessors\n  getAll(): Player[]; // returns cached players\n  getAllLogins(): string[]; // return array of logins\n  getPlayerbyNick(nickname: string): Player | null; // search by nickname\n  async getPlayer(login: string): Promise&lt;Player&gt;; // fetch or return cached player\n\n  // internal / lifecycle\n  async init(): Promise&lt;void&gt;; // registers server callbacks, fetches initial players\n  afterInit(): void; // registers additional callbacks\n  async syncFromServer(): Promise&lt;void&gt;; // not a direct public method, called by init\n}\n</code></pre> <ul> <li><code>getPlayer(login)</code> will return the cached <code>Player</code> if present; otherwise it will call the server's <code>GetDetailedPlayerInfo</code> to create and cache a new <code>Player</code> object.</li> <li>Calling <code>getPlayer()</code> for the server login will produce a console error and return an empty <code>Player</code> object \u2014 the server is not modeled as a player entity.</li> </ul>"},{"location":"devs/class/playermanager/#events-lifecycle","title":"Events &amp; lifecycle","text":"<p><code>PlayerManager</code> listens for and reacts to these server callbacks: - <code>Trackmania.PlayerInfoChanged</code>: when a player's short info line changes (team, spectator status), <code>PlayerManager</code> will update the cached <code>Player</code> via <code>syncFromPlayerInfo</code>. If the player is newly joined, it will call <code>getPlayer</code> to populate full details. - <code>Trackmania.PlayerConnect</code>: creates a new <code>Player</code> by calling <code>getPlayer</code> and emits <code>TMC.PlayerConnect</code> with the <code>Player</code> object. - <code>Trackmania.PlayerDisconnect</code>: emits <code>TMC.PlayerDisconnect</code> (with a cloned <code>Player</code> object) and removes the player from the cache.</p>"},{"location":"devs/class/playermanager/#examples","title":"Examples","text":""},{"location":"devs/class/playermanager/#basic-get-a-player-and-display-info","title":"Basic: Get a player and display info","text":"<pre><code>const p = await tmc.getPlayer('someLogin');\nif (!p) return;\ntmc.chat(`Player ${p.nickname}, admin=${p.isAdmin}.`, p.login);\n</code></pre>"},{"location":"devs/class/playermanager/#list-players-in-a-listwindow","title":"List players in a ListWindow","text":"<pre><code>this.addCommand('/players', async (login) =&gt; {\n  const players = tmc.players.getAll().map((p) =&gt; ({\n    login: p.login,\n    name: p.nickname,\n  }));\n  const window = new ListWindow(login);\n  window.title = 'Players online';\n  window.setColumns([{ key: 'login', title: 'Login', width: 30 }, { key: 'name', title: 'Name', width: 130 }]);\n  window.setItems(players);\n  await window.display();\n});\n</code></pre>"},{"location":"devs/class/playermanager/#find-by-nickname","title":"Find by nickname","text":"<pre><code>const player = tmc.players.getPlayerbyNick('SomeNick');\nif (player) {\n  tmc.chat(`${player.nickname} is currently online (login=${player.login}).`, yourLogin);\n}\n</code></pre>"},{"location":"devs/class/playermanager/#track-player-connectdisconnect-events","title":"Track Player connect/disconnect events","text":"<pre><code>tmc.server.addListener('TMC.PlayerConnect', async (player: Player) =&gt; {\n  tmc.chat(`Player connected: ${player.nickname}`);\n});\n\ntmc.server.addListener('TMC.PlayerDisconnect', async (player: Player) =&gt; {\n  tmc.chat(`Player disconnected: ${player.nickname}`);\n});\n</code></pre>"},{"location":"devs/class/playermanager/#best-practices","title":"Best practices","text":"<ul> <li>Use <code>getPlayer()</code> to retrieve a player prior to accessing detailed fields (e.g., <code>avatar</code>, <code>ladderStats</code>) \u2014 otherwise the fields may be undefined.</li> <li>Avoid mutating the <code>Player</code> object directly unless you're intentionally storing ephemeral or plugin-specific state. Prefer plugin-local storage or use namespaced keys.</li> <li>When diagnosing issues, check <code>tmc.server</code> callbacks and ensure <code>PlayerInfoChanged</code> payloads are processed correctly.</li> <li>For UI listing, prefer <code>getAll()</code> for consistent, cached values instead of calling <code>getPlayer()</code> in a loop.</li> </ul>"},{"location":"devs/class/playermanager/#troubleshooting","title":"Troubleshooting","text":"<ul> <li>If <code>getPlayer(login)</code> fails to fetch details, the server might be unreachable or not support <code>GetDetailedPlayerInfo</code> \u2014 check server logs.</li> <li>Duplicate logins: the manager guards against duplicate connections (kicks duplicate if login already connected) \u2014 this is a server-level safety measure.</li> <li>If <code>isAdmin</code> is unexpectedly false, check the <code>tmc.settings.admins</code> source and ensure the login is included.</li> </ul>"},{"location":"devs/class/plugins/","title":"Plugins","text":"<p>Back to Concept</p>"},{"location":"devs/class/plugins/#plugin-base-loader-moved","title":"Plugin base &amp; loader (moved)","text":"<p>This class-level doc has been merged into the developer-facing plugin guide:</p> <ul> <li>See Plugins guide for the full documentation covering the base <code>Plugin</code> class, <code>PluginLoader</code> APIs, manifest schema, resolver behavior, helper methods, and examples.</li> </ul> <p>If you are looking for the base class API or helpers (addListener, addCommand, addSetting, addColor, destroy, etc.), please consult the merged doc at <code>../plugins.md</code>.</p>"},{"location":"devs/class/sentry/","title":"Sentry","text":"<p>Back to Concept</p>"},{"location":"devs/class/sentry/#sentry-integration-coresentryts","title":"Sentry integration (core/sentry.ts)","text":""},{"location":"devs/class/sentry/#table-of-contents","title":"Table of contents","text":"<ul> <li>Controls</li> <li>Behavior</li> </ul> <p>MINIcontrol optionally reports errors to Sentry.io. The integration is a single module that initializes Sentry during startup.</p>"},{"location":"devs/class/sentry/#controls","title":"Controls","text":"<ul> <li><code>ERROR_REPORTING</code> (env): <code>true|false</code> (default <code>true</code>) \u2014 toggles error reporting on/off.</li> </ul> <p>If enabled, <code>sentry.init()</code> is called with package <code>release</code> <code>minicontrol@${process.env.npm_package_version}</code>.</p> <p>Sentry config is basic and intended to be opt-out by environment. You can disable it in runtime by setting <code>ERROR_REPORTING=false</code>.</p>"},{"location":"devs/class/server/","title":"Server","text":"<p>Back to Concept</p>"},{"location":"devs/class/server/#server-class","title":"Server class","text":"<p>Server class is used to communicate with the game server itself.</p>"},{"location":"devs/class/server/#table-of-contents","title":"Table of contents","text":"<ul> <li>API<ul> <li>call / send / multicall / multisend</li> <li>callScript / sendScript</li> <li>Override methods (addOverride / removeOverride)</li> <li>Listeners (addListener / removeListener / prependListener)</li> </ul> </li> <li>Supported events</li> <li>Authentication &amp; Initialization</li> <li>Mode Script Callbacks &amp; Normalization</li> <li>limitScriptCallbacks</li> <li>Notes &amp; best practices</li> </ul>"},{"location":"devs/class/server/#api","title":"API","text":"<p>The calls you can interact with the server:</p> <pre><code>class Server {\n\n    // call a xmlrpc method for server and WAIT for answer\n    async call(method, ...params): any;\n\n    // shorthand method to call script\n    async callScript(method: string, ...args: any);\n\n    // perform multicall for dedicated server and WAIT for answer\n    async multicall([\n        [method, ...params],\n        [method, ...params]\n        ]): any[];\n\n    // just send and ignore everything else\n    send(method, ...params)\n\n    // add override\n    async addOverride(method: string, callback: Function);\n    async removeOverride(method: string);\n    // add listener / remove listener\n    addListener(method: string, callback: any, obj?: object);\n    prependListener(method: string, callback: any, obj?: object);\n    removeListener(method: string, callback: any);\n    emit(method: string, ...args: any[]);\n\n}\n</code></pre>"},{"location":"devs/class/server/#supported-events","title":"Supported events","text":"<p>To make everything working with all generations of the games, some things had to changed. Callbacks starting with: <code>TrackMania.</code> and  <code>ManiaPlanet.</code> are all renamed to start with <code>Trackmania.</code> Custom events that should be used instead of the native ones:</p> <pre><code>// async onPlayerConnect(player: Player) {}\ntmc.server.addListener(\"TMC.PlayerConnect\", this.onPlayerConnect, this)\n\n// async onPlayerDisconnect(player: Player) {}\ntmc.server.addListener(\"TMC.PlayerDisconnect\", this.onPlayerDisconnect, this)\n\n// async onPlayerCheckpoint(login:string, racetime:int, checkpointinrace:int) {}\ntmc.server.addListener(\"TMC.PlayerCheckpoint\", this.onPlayerCheckpoint, this);\n\n// async onPlayerFinish(login:string, time:int) {}\ntmc.server.addListener(\"TMC.PlayerFinish\", this.finish, this);\n\n// async onPlayerGiveup() {}\ntmc.server.addListener(\"TMC.PlayerGiveup\", this.giveup, this);\n\n//  onVoteCancel(data: VoteStruct) {}\ntmc.server.addListener(\"TMC.Vote.Cancel\", this.voteCancel, this);\n\n//  onVoteDeny(data: VoteStruct) {}\ntmc.server.addListener(\"TMC.Vote.Deny\", this.voteDeny, this);\n\n//  onVotePass(data: VoteStruct) {}\ntmc.server.addListener(\"TMC.Vote.Pass\", this.votePass, this);\n\n// generic ones use this callbacks\n\ntmc.server.addListener(\"Trackmania.*\", this.callback, this);\n</code></pre>"},{"location":"devs/class/server/#common-tmc-events-normalized","title":"Common TMC events (normalized)","text":"<p>MINIcontrol normalizes (and exposes) common dedicated server callbacks via the <code>TMC.</code> namespace. Plugins should prefer these events over raw <code>Trackmania.</code> or <code>ManiaPlanet.</code> callbacks:</p> <ul> <li><code>TMC.PlayerConnect</code> - Emitted with a <code>Player</code> object when a player connects; plugin typically fetches player details with <code>await tmc.players.getPlayer(login)</code>.</li> <li><code>TMC.PlayerDisconnect</code> - Emitted with a <code>Player</code> object when a player disconnects.</li> <li><code>TMC.PlayerCheckpoint</code> - Emitted with: <code>(login: string, racetime: number, checkpointIndex: number, rawData?)</code>.</li> <li><code>TMC.PlayerFinish</code> - Emitted with: <code>(login: string, racetime: number)</code> when a player finishes.</li> <li><code>TMC.PlayerGiveup</code> - Emitted when a player gives up.</li> <li><code>TMC.BeginMap</code> or <code>Trackmania.BeginMap</code> - Emitted when a new map begins; data includes the new map object.</li> <li><code>TMC.BeginRound</code> / <code>Trackmania.BeginRound</code> - Emitted when a round begins (useful for per-round timers).</li> <li><code>TMC.MapListModified</code> - Emitted when the server's maplist changed.</li> <li><code>TMC.Vote.Cancel</code>, <code>TMC.Vote.Deny</code>, <code>TMC.Vote.Pass</code> - Vote lifecycle events (payload depends on server call signature).</li> </ul> <p>These <code>TMC.</code> events are safe across games and provide a uniform payload for plugin authors.</p>"},{"location":"devs/class/server/#when-to-use-call-send-multicall-multisend","title":"When to use call / send / multicall / multisend","text":"<p>Server interactions generally fall into two categories:</p> <ul> <li>Blocking calls that expect a response (use <code>call</code>/<code>multicall</code>).</li> <li>Fire-and-forget sends where no response is needed (use <code>send</code>/<code>multisend</code>).</li> </ul>"},{"location":"devs/class/server/#tmcservercallmethod-args","title":"<code>tmc.server.call(method, ...args)</code>","text":"<ul> <li>Use when you need a return value or must wait for the action to complete. This is the most commonly used method when fetching data or waiting for server results.</li> <li>Example: <pre><code>const currentMap = await tmc.server.call('GetCurrentMapInfo');\n</code></pre></li> </ul>"},{"location":"devs/class/server/#tmcserversendmethod-args","title":"<code>tmc.server.send(method, ...args)</code>","text":"<ul> <li>Use to dispatch a command without waiting for a response. Useful for UI updates and commands where the result doesn't matter.</li> <li>Example: <pre><code>tmc.server.send('SendDisplayManialinkPage', xml, 0, false);\n</code></pre></li> </ul>"},{"location":"devs/class/server/#tmcservermulticallcalls-method-args","title":"<code>tmc.server.multicall(calls: [method, ...args][])</code>","text":"<ul> <li>Batch multiple <code>call</code> requests into a single round-trip and obtain an array of responses. Use this for efficiency and to avoid many separate <code>call</code> invocations.</li> <li>Example: <pre><code>const calls = [ ['GetMapInfo', 'some.gbx'], ['GetMapInfo', 'another.gbx'] ];\nconst results = await tmc.server.multicall(calls);\n</code></pre></li> </ul>"},{"location":"devs/class/server/#tmcservermultisendcalls-method-args","title":"<code>tmc.server.multisend(calls: [method, ...args][])</code>","text":"<ul> <li>Batch multiple <code>send</code> operations in a single request without expecting responses. Use this when you want to send many fire-and-forget commands.</li> <li>Example: <pre><code>const calls = [ ['SendDisplayManialinkPageToLogin', login, xml, 0, false], ... ];\nawait tmc.server.multisend(calls);\n</code></pre></li> </ul>"},{"location":"devs/class/server/#choosing-between-them","title":"Choosing between them","text":"<ul> <li>When you need a result: use <code>call</code> or <code>multicall</code>.</li> <li>When you just need to trigger a server action and don't need the result: use <code>send</code> or <code>multisend</code>.</li> <li>Use <code>multicall</code>/<code>multisend</code> to group calls for performance when issuing many calls in quick succession.</li> </ul>"},{"location":"devs/class/server/#notes-best-practices","title":"Notes &amp; best practices","text":"<p>Here are general recommendations when interacting with the server and writing plugins:</p> <ul> <li> <p>Use <code>call</code> when you need a response, and always await it inside try/catch to handle server errors: <pre><code>try {\n    const info = await tmc.server.call('GetMapInfo', 'myMap.Gbx');\n} catch (e) {\n    tmc.cli(`Error fetching map info: ${e.message}`);\n}\n</code></pre></p> </li> <li> <p>Use <code>send</code> for fire-and-forget operations. If the server call might fail silently, consider using <code>call</code> to confirm status.</p> </li> <li> <p>Prefer <code>multicall</code>/<code>multisend</code> when dealing with many calls: they reduce latency and server round-trips.</p> </li> <li> <p>Avoid blocking work in event listeners; perform heavy work asynchronously and avoid long-running synchronous tasks.</p> </li> <li> <p>When using <code>addListener</code>, provide the bound object (third parameter) and use <code>removeListener</code> with the same callback to avoid leaks.</p> </li> <li> <p>Use <code>addOverride</code>/<code>removeOverride</code> in tests or temporary runtime emulation, and always remove overrides to restore original behavior.</p> </li> <li> <p>For script-related operations (callScript), supply sensible timeouts and fallback logic as script methods can hang or time out.</p> </li> <li> <p>Respect game-specific differences (e.g., <code>Trackmania</code> vs <code>TmForever</code> replacements) and use <code>tmc.server.fetchServerInfo()</code> to detect the game and adjust logic.</p> </li> </ul>"},{"location":"devs/class/server/#see-also","title":"See also","text":"<ul> <li>GBX Client (XML-RPC transport)</li> <li>MiniControl (tmc) runtime API</li> <li>UiManager (examples of efficient multisend usage)</li> </ul>"},{"location":"devs/class/server/#authentication-initialization","title":"Authentication &amp; Initialization","text":"<p>MiniControl uses the following sequence to initialize a running server connection:</p> <ol> <li><code>tmc.server.connect(host, port)</code> \u2014 Connect to the remote XML-RPC/GBX server.</li> <li><code>tmc.server.call('Authenticate', user, pass)</code> \u2014 Authenticate as a SuperAdmin account.</li> <li><code>tmc.server.fetchServerInfo()</code> \u2014 Helper to populate local <code>tmc.server.version</code>, <code>tmc.server.packmask</code>, <code>tmc.server.login</code> and <code>tmc.server.name</code> values. It calls several API methods internally (GetMainServerPlayerInfo, GetServerOptions, GetVersion etc.).</li> <li>Enable callbacks &amp; configure API version depending on the game type (<code>Trackmania</code>, <code>TmForever</code>, <code>ManiaPlanet</code>).</li> </ol> <p>Example minimal initialization (already handled by MiniControl core): <pre><code>const connected = await tmc.server.connect('127.0.0.1', 5000);\nawait tmc.server.call('Authenticate', 'SuperAdmin', 'SuperAdmin');\nawait tmc.server.fetchServerInfo();\n// enable callbacks (core sets relevant flags automatically)\nawait tmc.server.send('EnableCallbacks', true);\n</code></pre></p> <p>Notes: - MiniControl will attempt to set the correct API version for <code>Trackmania</code> / <code>ManiaPlanet</code> to ensure compatibility. - It also updates <code>tmc.mapsPath</code> (games use different API names: <code>GetMapsDirectory</code> vs <code>GetTracksDirectory</code> for TmForever) and optionally toggles <code>XmlRpc.EnableCallbacks</code> via <code>sendScript()</code>.</p>"},{"location":"devs/class/server/#callscript-sendscript","title":"callScript / sendScript","text":""},{"location":"devs/class/server/#tmcservercallscriptmethod-args","title":"<code>tmc.server.callScript(method, ...args)</code>","text":"<ul> <li>A helper to invoke a ModeScript/ManiaScript function and wait for its result via events.</li> <li>Implementation detail: <code>callScript</code> issues the script call and returns a promise which resolves once the script emits the associated callback event (the server emits an event corresponding to the script response). A timeout is used to prevent infinite waits.</li> <li>Example: <pre><code>// Call a script function and capture result\nconst users = await tmc.server.callScript('GetPlayersWithProperty', 'someProperty');\n</code></pre></li> </ul>"},{"location":"devs/class/server/#tmcserversendscriptmethod-args","title":"<code>tmc.server.sendScript(method, ...args)</code>","text":"<ul> <li>Similar to <code>callScript</code> but fire-and-forget. The caller doesn't wait for a response event. Useful for scripts that don't return a value. <pre><code>// Just send a script call\nawait tmc.server.sendScript('XmlRpc.EnableCallbacks', 'true');\n</code></pre></li> </ul>"},{"location":"devs/class/server/#addoverride-removeoverride","title":"addOverride / removeOverride","text":"<p>These helpers let you intercept GBX method calls and provide custom implementations; this is useful for testing, emulation, or interception.</p> <p>Example: <pre><code>tmc.server.addOverride('GetMapInfo', (filename) =&gt; {\n    // provide a stubbed response or forward to a custom handler\n    return { UId: 'stub', Name: 'Stubbed map' };\n});\n\n// To restore normal behavior\ntmc.server.removeOverride('GetMapInfo');\n</code></pre></p>"},{"location":"devs/class/server/#listeners-addlistener-prependlistener-removelistener","title":"Listeners (addListener, prependListener, removeListener)","text":"<ul> <li><code>addListener(method, callback, obj)</code> binds and registers a listener wrapper that stores the original callback in <code>wrapper.listener</code> (so <code>removeListener</code> can find and remove it cleanly). Use it to bind server events and ensure you can remove them reliably.</li> <li><code>prependListener</code> puts the listener at the beginning of the listener list.</li> <li><code>removeListener</code> removes the listener and any wrapper with <code>wrapper.listener === callback</code>.</li> </ul>"},{"location":"devs/class/server/#example","title":"Example","text":"<pre><code>// Register\ntmc.server.addListener('TMC.PlayerConnect', this.onPlayerConnect, this);\n\n// Remove\ntmc.server.removeListener('TMC.PlayerConnect', this.onPlayerConnect);\n</code></pre>"},{"location":"devs/class/server/#modescript-callbacks-normalization","title":"ModeScript callbacks &amp; normalization","text":"<p>MiniControl normalizes differences between various Trackmania server versions. Key points:</p> <ul> <li>Many events are delivered via ModeScript callbacks (e.g., <code>ModeScriptCallbackArray</code> or <code>Trackmania.ModeScriptCallbackArray</code>). MiniControl turns these into unified <code>TMC.*</code> events.</li> <li>The core <code>onCallback</code> implementation in <code>core/server.ts</code> normalizes method names (e.g., <code>ManiaPlanet.</code> -&gt; <code>Trackmania.</code> and <code>Challenge</code> -&gt; <code>Map</code>) and emits <code>TMC.*</code> events for listeners.</li> </ul> <p>Example: <code>ModeScriptCallbackArray</code> for waypoint or other race events is converted into <code>TMC.PlayerFinish</code>, <code>TMC.PlayerCheckpoint</code> etc.</p>"},{"location":"devs/class/server/#limitscriptcallbacks","title":"limitScriptCallbacks","text":"<p><code>tmc.server.limitScriptCallbacks()</code> is a helper used during initialization (for <code>Trackmania</code> / <code>ManiaPlanet</code>) to restrict which ModeScript callbacks scripts can call. This reduces the number of script callbacks the server has to process and helps prevent callback flooding (especially when many plugins or scripts register events).</p> <p>What it does: - Fetches the list of registered script callbacks via <code>XmlRpc.GetCallbacksList</code>. - Blocks non-essential callbacks and only enables those required for typical behaviors (start/end events, certain game events). - Logs the list of enabled callbacks and the reduction it achieved.</p> <p>Use case: - Enable by default in production to reduce server overhead. You can control behavior by setting <code>XMLRPC_LIMIT_SCRIPT_CALLBACKS</code> env var.</p>"},{"location":"devs/class/settingsmanager/","title":"Settingsmanager","text":"<p>Back to Concept</p>"},{"location":"devs/class/settingsmanager/#settingsmanager-settings-colors","title":"SettingsManager (Settings &amp; Colors)","text":"<p>The <code>SettingsManager</code> handles persistent settings and theme colors for the controller and the plugins. It provides registration helpers for settings and colors, persistence support, callbacks on change, and admin list management.</p>"},{"location":"devs/class/settingsmanager/#table-of-contents","title":"Table of contents","text":"<ul> <li>Overview</li> <li>Data files &amp; persistence</li> <li>Default settings &amp; colors</li> <li>API &amp; usage</li> <li>Events emitted</li> <li>Examples</li> <li>Best practices &amp; notes</li> </ul>"},{"location":"devs/class/settingsmanager/#overview","title":"Overview","text":"<p><code>SettingsManager</code> centralizes configuration across core and plugins: - Store and read settings (<code>tmc.settings.get()</code> / <code>tmc.settings.set()</code>) - Register settings with default values and callbacks that run on update - Manage colors (theme palette), register color settings and callbacks - Persist settings and colors to JSON files per server - Manage list of admin logins and persist them</p> <p>It is usually accessible through <code>tmc.settings</code> at runtime and plugin authors should register settings and colors with the manager \u2014 the plugin base class provides <code>addSetting()</code> and <code>addColor()</code> shortcuts which track registrations for cleanup.</p>"},{"location":"devs/class/settingsmanager/#data-files-persistence","title":"Data files &amp; persistence","text":"<p>By default, <code>SettingsManager</code> stores data under <code>userdata</code> with filenames suffixed by the server login. The file names are computed at runtime using <code>import.meta.dirname</code> and <code>tmc.server.login</code>: - <code>settings_&lt;serverlogin&gt;.json</code> - <code>colors_&lt;serverlogin&gt;.json</code> - <code>admins_&lt;serverlogin&gt;.json</code></p> <p>Files are created when they don't exist. <code>SettingsManager.load()</code> reads defaults and persisted entries at startup. Changes are saved by calling <code>save()</code> (called during <code>set</code>/<code>setColor</code>/<code>addAdmin</code>/<code>removeAdmin</code>).</p> <p>If the files are unreadable or can't be written a fatal error occurs (controller prints a message and exits).</p>"},{"location":"devs/class/settingsmanager/#default-settings-colors","title":"Default settings &amp; colors","text":"<p>The manager keeps two sets of defaults: - <code>_defaultSettings</code>: base default values registered by code - <code>_defaultColors</code>: default color palette (hex 3 or 6-digit strings, e.g. <code>fff</code>)</p> <p>Colors can be overridden by environment variables: <code>COLOR_&lt;NAME&gt;</code> will set a specific color at startup. The manager also computes lighter/darker variants for <code>button_bg</code> and <code>window_bg</code> automatically (uses <code>modLightness</code> helper).</p>"},{"location":"devs/class/settingsmanager/#api-usage","title":"API &amp; usage","text":"<p>Common usage from plugins and core:</p> <pre><code>// Register a setting\ntmc.settings.register('myplugin.enableFeature', true, async (newVal, oldVal) =&gt; {\n  // called when setting changes\n}, 'Toggle my plugin feature');\n\n// Read a setting\nconst enabled = tmc.settings.get('myplugin.enableFeature');\n\n// Reset a setting to default\nawait tmc.settings.reset('myplugin.enableFeature');\n\n// Register a color setting\ntmc.settings.registerColor('myplugin.header', 'f07', async (newVal) =&gt; {\n  // called when color changed\n}, 'Header color for my plugin');\n\n// Get color\nconst header = tmc.settings.getColor('myplugin.header');\n\n// Set color\nawait tmc.settings.setColor('myplugin.header', '0f0');\n\n// Add/remove admin\ntmc.settings.addAdmin('playerLogin');\ntmc.settings.removeAdmin('playerLogin');\n</code></pre> <p>Important methods &amp; behavior: - <code>register(key, default, callback, description)</code> \u2014 register a setting with optional callback (async) and description - <code>unregister(key)</code> \u2014 remove a setting from defaults and live settings - <code>get(key)</code> / <code>getDefault(key)</code> \u2014 read live or default value - <code>set(key, value)</code> \u2014 update a setting and call callback if it changed (persist) - <code>reset(key)</code> \u2014 reset setting to default and call callback - <code>registerColor(key, default, callback, description)</code> \u2014 register color value - <code>getColor(key)</code> / <code>setColor(key, value)</code> / <code>resetColor(key)</code> \u2014 color equivalents - <code>addAdmin(login)</code> / <code>removeAdmin(login)</code> \u2014 manage runtime admin list; master admins (ADMINS env) can\u2019t be removed</p>"},{"location":"devs/class/settingsmanager/#callback-semantics","title":"Callback semantics","text":"<ul> <li>Callbacks are executed asynchronously after we persist the change and before emitting the <code>TMC.SettingsChanged</code> or <code>TMC.ColorsChanged</code> events.</li> <li>If new value equals previous value, the manager does not call callbacks.</li> </ul>"},{"location":"devs/class/settingsmanager/#events-emitted","title":"Events emitted","text":"<p>SettingsManager emits events on the server bus so other parts of the system can react: - <code>TMC.SettingsChanged</code> \u2014 when any setting is modified - <code>TMC.ColorsChanged</code> \u2014 when a color is changed - <code>TMC.AdminsChanged</code> \u2014 when admin list changes</p> <p>These events are emitted after the manager persists changes and calls any associated change callbacks.</p>"},{"location":"devs/class/settingsmanager/#examples","title":"Examples","text":""},{"location":"devs/class/settingsmanager/#register-a-setting-with-callback","title":"Register a setting (with callback)","text":"<pre><code>tmc.settings.register('myplugin.enabled', true, async (n, o, _k) =&gt; {\n  if (n) {\n    // enable plugin feature\n  } else {\n    // disable plugin feature\n  }\n}, 'Enable or disable my plugin');\n</code></pre>"},{"location":"devs/class/settingsmanager/#toggle-a-color-value","title":"Toggle a color value","text":"<pre><code>// register\ntmc.settings.registerColor('myplugin.header', 'f07', async (n) =&gt; {\n  // apply header color change to all UIs or widgets\n});\n\n// set later\nawait tmc.settings.setColor('myplugin.header', '0f0');\n</code></pre>"},{"location":"devs/class/settingsmanager/#admin-management","title":"Admin management","text":"<pre><code>tmc.settings.addAdmin('login1');\ntmc.settings.removeAdmin('login1');\n</code></pre>"},{"location":"devs/class/settingsmanager/#best-practices-notes","title":"Best practices &amp; notes","text":"<ul> <li>Register settings and colors during <code>onLoad</code> of your plugin and avoid registering inside a frequently executed code path.</li> <li>Use <code>this.addSetting()</code> and <code>this.addColor()</code> (plugin base helpers) instead of <code>tmc.settings.register()</code> \u2014 those track changes and remove settings automatically on plugin unload.</li> <li>Use <code>reset()</code> when you want to revert a setting to default from the UI.</li> <li>If you want to override colors globally for a running controller, use environment variables <code>COLOR_&lt;NAME&gt;</code> or change via the UI which calls <code>setColor()</code>.</li> <li>The manager preserves default settings and only writes non-default keys to <code>settings.json</code> to keep files compact.</li> </ul>"},{"location":"devs/class/settingsmanager/#troubleshooting","title":"Troubleshooting","text":"<ul> <li>If settings don't persist: confirm the controller can write into <code>userdata</code> folder and the <code>settings_&lt;login&gt;.json</code> file exists with correct permissions.</li> <li>If callbacks do not fire: verify your callback is set in <code>register()</code> and you call <code>set()</code> with a changed value (the manager ignores identical values).</li> <li>If <code>addAdmin()</code> or <code>removeAdmin()</code> fails: confirm the login is not a master admin (can't remove) and that <code>masterAdmins</code> are set via <code>ADMINS</code> env.</li> </ul>"},{"location":"devs/class/uimanager/","title":"Uimanager","text":"<p>Back to Concept</p>"},{"location":"devs/class/uimanager/#uimanager","title":"UiManager","text":"<p>UiManager is an adapter that handles the lifecycle of Manialinks and UI-related events. It acts as the single point for sending/managing Manialinks (widgets, windows, list windows etc.) to the server, converts templates for compatibility (e.g., Trackmania vs TmForever), and maintains a global and per-player manialink registry.</p> <p>Most plugin code will use higher-level UI classes such as <code>Widget</code>, <code>Window</code> or <code>ListWindow</code>. You rarely need to operate with <code>UiManager</code> directly, but it is useful to understand the lifecycle and API when building custom UI components or when you need to manipulate the UI outside of those classes.</p> <p>We use Twig as our template language. See Twig docs for the syntax and features: https://twig.symfony.com/doc/3.x/templates.html</p> <p>Manialinks in MINIcontrol use the manialink v3 markup. For general ManiaScript / UI concepts refer to the official tutorial: https://wiki.trackmania.io/en/ManiaScript/UI-Manialinks/</p> <p>Note: Use the safe elements across supported games: <code>&lt;frame&gt;</code>, <code>&lt;quad&gt;</code>, <code>&lt;label&gt;</code>, <code>&lt;entry&gt;</code>, <code>&lt;textedit&gt;</code>. You can create high-quality clickable, focused areas using <code>focusareacolor1</code>/<code>focusareacolor2</code> attributes on <code>label</code> elements.</p>"},{"location":"devs/class/uimanager/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Key concepts</li> <li>Where to access</li> <li>Important methods and behavior</li> <li>Lifecycle</li> <li>Rendering, display and lifecycle</li> <li>Actions management</li> <li>Clipboard helper</li> <li>UI Modules &amp; TmForever custom UI</li> <li>Misc</li> <li>Examples</li> <li>Performance tips &amp; notes</li> <li>Troubleshooting</li> <li>Related classes &amp; docs</li> </ul>"},{"location":"devs/class/uimanager/#key-concepts","title":"Key concepts","text":"<ul> <li>Public vs Player-specific manialinks</li> <li>Public manialinks are shown to all players by default. They are registered in <code>UiManager.publicManialinks</code>.</li> <li>Player-specific manialinks are delivered to a single player (by login) and are stored in <code>UiManager.playerManialinks[login]</code>.</li> <li> <p>The manager ensures that duplicates are cleaned up \u2014 if a new manialink with the same id is displayed, the old one is destroyed automatically.</p> </li> <li> <p>Hiding and toggles</p> </li> <li>The manager supports a \u2018hide all manialinks\u2019 toggle (answer code <code>-2</code>) per player. When activated the manager hides manialinks to prevent spam. When a player toggles the state it is stored in <code>UiManager.hiddenManialinks</code>.</li> <li> <p>Plugins / templates can provide an action to toggle hiding with <code>action=\"-2\"</code>. for users this is bind to pressing F7 key.</p> </li> <li> <p>Action handlers</p> </li> <li> <p>Use the UiManager action registry to register callback handlers for events emitted by manialinks. Use <code>tmc.ui.addAction(callback, data)</code> to create an action id, then use that id in templates. The manager will call the registered callback on click.</p> </li> <li> <p>TmForever compatibility</p> </li> <li>For TmForever the manager has a conversion step that transforms<code>pos</code>/<code>size</code> attributes into <code>posn</code>/<code>sizen</code> with appropriate scaling and maps <code>z-index</code> to the third coordinate. This conversion happens using <code>UiManager.convert()</code> (called automatically when sending manialinks).</li> </ul>"},{"location":"devs/class/uimanager/#where-to-access","title":"Where to access","text":"<p>Use the runtime global: <code>tmc.ui</code>. For example in plugin TypeScript code:</p> <pre><code>// show a Widget via UI manager\nconst widget = new Widget(\"widget.xml.twig\", import.meta.dirname);\nawait tmc.ui.displayManialink(widget);\n</code></pre> <p>Most UI classes will have <code>display()</code> convenience methods that internally call <code>tmc.ui.displayManialink()</code> for you.</p>"},{"location":"devs/class/uimanager/#important-methods-and-behavior","title":"Important methods and behavior","text":"<p>Below are the most relevant methods available on <code>UiManager</code> with descriptions and small examples. For all method signatures below assume access via <code>tmc.ui</code>.</p>"},{"location":"devs/class/uimanager/#lifecycle","title":"Lifecycle","text":"<ul> <li><code>init()</code> (internal): sets up event handlers and registers TmForever HUD settings. Called by the core at startup.</li> <li><code>afterInit()</code> (internal): finishes initialization actions such as sending the global manialink and synchronizing HUD settings.</li> </ul>"},{"location":"devs/class/uimanager/#rendering-display-and-lifecycle","title":"Rendering, display and lifecycle","text":"<ul> <li><code>displayManialink(manialink: Manialink)</code></li> <li>Register and show a manialink. Handles both public and per-player manialinks. Destroys older manialinks with the same id.</li> <li>For player-specific manialinks, if the manialink is an instance of <code>Window</code>, all existing <code>Window</code> manialinks for that player are destroyed first.</li> <li> <p>Example:   <pre><code>const widget = new Widget(\"widget.xml.twig\", import.meta.dirname);\nawait tmc.ui.displayManialink(widget);\n</code></pre></p> </li> <li> <p><code>displayManialinks(manialinks: Manialink[])</code></p> </li> <li>Equivalent to calling <code>displayManialink</code> multiple times, but optimized and sends calls in batches (chunked) to avoid flooding the server.</li> <li>Example (using UI objects, preferred):   <pre><code>const w1 = new Widget('a.xml.twig', import.meta.dirname);\nconst w2 = new Widget('b.xml.twig', import.meta.dirname);\nawait tmc.ui.displayManialinks([w1, w2]);\n</code></pre></li> <li>Under the hood: UiManager renders each Manialink, builds the XML call array and uses <code>tmc.server.multisend()</code> in batches to efficiently dispatch them.</li> <li>If you need a fully manual approach, build an array of calls and call <code>tmc.server.multisend(calls)</code> directly. This is useful if you already have XML and don't need UiManager to render/track objects.</li> <li> <p>See the UI System Examples for a <code>multisend</code> example: UI System \u2014 Example: Batch display manialinks (multisend)</p> </li> <li> <p><code>refreshManialink(manialink: Manialink)</code></p> </li> <li> <p>Re-renders and sends the existing manialink again (keep the same id). Useful when only the data changed.</p> </li> <li> <p><code>hideManialink(manialink: Manialink)</code></p> </li> <li> <p>Hides a manialink without destroying it (sends an empty manialink id payload). Useful for toggling visibility without destroying references.</p> </li> <li> <p><code>destroyManialink(manialink: Manialink, hide = true)</code></p> </li> <li>Destroy and cleanup a manialink. This removes action handlers from the internal registry, calls <code>manialink.cleanReferences()</code> (which plugin Manialink objects should implement), and removes it from the public or player maps. If <code>hide</code> is true, calls <code>hideManialink()</code> first.</li> </ul>"},{"location":"devs/class/uimanager/#actions-management","title":"Actions management","text":"<ul> <li><code>addAction(callback: CallableFunction, data: any): string</code></li> <li>Register an action that can be used by templates. Returns an action id. When the user clicks an element with that action, the callback runs with (login, data, entries) arguments.</li> <li> <p>Example:   <pre><code>const action = tmc.ui.addAction((login, data) =&gt; {\n    // callback code\n}, { plugin: \"example\" });\n// use `action` in your template e.g. &lt;label action=\"{action}\" /&gt;\n</code></pre></p> </li> <li> <p><code>removeAction(actionId: string)</code></p> </li> <li>Remove previously registered action. This is typically called by the manialink <code>destroy()</code> method.</li> </ul>"},{"location":"devs/class/uimanager/#clipboard-helper","title":"Clipboard helper","text":"<ul> <li><code>setClipboard(login: string, text: string)</code></li> <li>Convenience method to set the clipboard for a specific player (sends a manialink with a script call to <code>System.ClipboardSet</code>). The method properly escapes quotes and replaces dangerous sequences like <code>--</code> to avoid script comment injection.</li> <li>Example:   <pre><code>tmc.ui.setClipboard(playerLogin, \"https://example.com/download/123\");\n</code></pre></li> </ul>"},{"location":"devs/class/uimanager/#ui-modules-tmforever-custom-ui","title":"UI Modules &amp; TmForever custom UI","text":"<ul> <li><code>getUiProperties()</code></li> <li>Fetch UI module properties from the server (used in Trackmania for finer UI adjustments).</li> <li><code>setUiProperty(id: string, property: string, value: any)</code></li> <li>Set a property for a specific UI module (e.g., scale, position or visibility). If the module is not found in the local cache this method logs an error.</li> <li><code>sendUiProperties()</code></li> <li>Push the locally modified UI module properties back to the server using <code>Common.UIModules.SetProperties</code>.</li> </ul> <p>For TmForever there is a small set of HUD elements that can be toggled using a custom UI feature. UiManager keeps a <code>tmnfCustomUi</code> object (default values defined in code), and exposes helpers:</p> <ul> <li><code>setCustomUI(key: string, value: boolean)</code> \u2014 update a tmnf custom UI key and send it to the server</li> <li><code>getCustomUI()</code> \u2014 returns the current map of tmnf custom UI keys</li> <li><code>syncTmfHudSettings()</code> \u2014 reads the registered <code>tmf.hud.*</code> settings and synchronize the manager state</li> </ul> <p>These functions are used to implement HUD toggling for TmForever and to send the correct custom UI object in a <code>SendDisplayManialinkPage</code> call.</p>"},{"location":"devs/class/uimanager/#misc","title":"Misc","text":"<ul> <li><code>uuid(): string</code> \u2014 returns a unique id for manialinks. Prefixed with <code>tmc</code> for non TmForever games.</li> <li><code>convert(text: string): string</code> \u2014 For TmForever only: convert legacy pos/size attributes to <code>posn</code>/<code>sizen</code> and transforms <code>z-index</code> values. This is run automatically when sending manialinks via <code>UiManager</code>.</li> </ul>"},{"location":"devs/class/uimanager/#examples","title":"Examples","text":""},{"location":"devs/class/uimanager/#display-a-public-widget","title":"Display a public widget","text":"<pre><code>import Widget from \"../core/ui/widget\";\n\nconst widget = new Widget(\"widget.xml.twig\", import.meta.dirname);\nawait tmc.ui.displayManialink(widget);\n</code></pre>"},{"location":"devs/class/uimanager/#register-and-use-actions","title":"Register and use actions","text":"<pre><code>const actionId = tmc.ui.addAction((login, data, entries) =&gt; {\n  tmc.cli(`${login} clicked`);\n  // you can use the passed `data` as context\n}, { some: \"payload\" });\n\n// in your template\n// &lt;label action=\"{actionId}\" text=\"Click me\" /&gt;\n\n// When the manialink is destroyed, the UiManager will call removeAction automatically\n</code></pre>"},{"location":"devs/class/uimanager/#use-clipboard-helper","title":"Use clipboard helper","text":"<pre><code>tmc.ui.setClipboard(\"playerLogin\", \"https://example.com/maps/123\");\n</code></pre>"},{"location":"devs/class/uimanager/#hiding-manialinks-from-the-built-in-global-manialink","title":"Hiding manialinks (from the built-in global manialink)","text":"<p>The manager sends a default global manialink with a label action set to <code>-2</code>. Players can toggle the hidden state; the manager will store it and will avoid sending manialinks to players with hidden state enabled.</p>"},{"location":"devs/class/uimanager/#performance-tips-notes","title":"Performance tips &amp; notes","text":"<ul> <li><code>displayManialinks</code> chunks multiple manialinks to avoid server flooding. The internal chunk size is set to 15 calls per batch and uses <code>tmc.server.multisend()</code>.</li> <li>Avoid re-rendering a manialink every frame; use <code>refreshManialink()</code> only when you need to update content.</li> <li>Actions are stored internally in a hash table. Always clean resources and let your manialink <code>destroy()</code> method remove them.</li> </ul>"},{"location":"devs/class/uimanager/#troubleshooting","title":"Troubleshooting","text":"<ul> <li>If pos/size attributes appear wrong in TmForever, confirm that the template uses standard <code>pos</code>/<code>size</code> and let UiManager <code>convert()</code> run. For advanced control prefer to use <code>posn/sizen</code> explicitly when authoring templates for TmForever.</li> <li>If a player cannot see your manialink, check <code>hiddenManialinks</code>, and whether the manialink <code>canHide</code> flag exists in the manialink class. Players that have hidden manialinks won't see public manialinks that allow hiding.</li> </ul>"},{"location":"devs/class/uimanager/#related-classes-docs","title":"Related classes &amp; docs","text":"<ul> <li>Widget Class \u2014 Persistent HUD widgets that use <code>UiManager</code> indirectly</li> <li>Window Class \u2014 Temporary dialogs and overlays</li> <li>ListWindow Class \u2014 Paginated data table helpers (extends <code>Window</code>)</li> <li>UI System Overview \u2014 Full guide to templates, classes, and examples</li> <li><code>core/uimanager.ts</code> \u2014 Implementation reference (source code): <code>core/uimanager.ts</code></li> </ul> <p>Other related manager docs: - PlayerManager \u2014 Player helper functions and login list retrieval - SettingsManager \u2014 HUD and persistent settings used by UiManager (tmf.hud.* settings) - Maps Manager \u2014 Example usage of <code>ListWindow</code> and UI for maps listing - Chat &amp; Commands \u2014 Interactions with ListWindow and UI-based help pages</p> <p>If you want more examples added (e.g., ListWindow batching, multi-recipient updates), tell me which examples and I'll add them to this doc. \u2705</p>"},{"location":"devs/class/utils/","title":"Utils","text":"<p>Back to Concept</p>"},{"location":"devs/class/utils/#utilities-helpers-coreutilsts","title":"Utilities &amp; helpers (core/utils.ts)","text":""},{"location":"devs/class/utils/#table-of-contents","title":"Table of contents","text":"<ul> <li>Common functions</li> <li>Important helpers</li> <li>Best practices</li> </ul> <p><code>core/utils.ts</code> contains many commonly used helper functions across the core and plugins. These utilities are safe to import and use in plugins.</p>"},{"location":"devs/class/utils/#common-functions","title":"Common functions","text":""},{"location":"devs/class/utils/#sleepms-number","title":"sleep(ms: number)","text":"<p>Simple sleep helper.</p> <pre><code>await sleep(200);\n</code></pre>"},{"location":"devs/class/utils/#randomintmin-max","title":"randomInt(min, max)","text":"<p>Return random integer in range [min, max].</p>"},{"location":"devs/class/utils/#uuidv4","title":"uuidv4()","text":"<p>Generate a RFC4122 v4 UUID.</p>"},{"location":"devs/class/utils/#processcolorstringstr-prefix","title":"processColorString(str, prefix=\"\")","text":"<p>Map <code>\u00a4color\u00a4</code> style markers (used internally for logging) into Trackmania color codes (<code>$rgb</code>) or optional prefix.</p> <p>Useful when building <code>tmc</code> console messages to maintain colorization.</p>"},{"location":"devs/class/utils/#chunkarrayarray-chunksize","title":"chunkArray(array, chunkSize)","text":"<p>Split an array into sub-arrays of size <code>chunkSize</code>.</p>"},{"location":"devs/class/utils/#modlightnesscolor-percent","title":"modLightness(color, percent)","text":"<p>Adjust color luminance and return new hex string.</p>"},{"location":"devs/class/utils/#rgb2hsl-hsl2rgb","title":"rgb2hsl / hsl2rgb","text":"<p>Conversion helpers used by <code>modLightness</code>.</p>"},{"location":"devs/class/utils/#getcountryfrompathpath","title":"getCountryFromPath(path)","text":"<p>Return the country part of a map path string (handles ManiaPlanet / TMF path semantics).</p>"},{"location":"devs/class/utils/#parseentriesentries","title":"parseEntries(entries)","text":"<p>Convert an array of entry structures (from the API) into a key-&gt;value map, using <code>castType</code> to normalize numbers/booleans.</p>"},{"location":"devs/class/utils/#htmlentitiesstr","title":"htmlEntities(str)","text":"<p>Important for Manialinks: - Escapes XML reserved characters (<code>&lt;</code>, <code>&gt;</code>, <code>&amp;</code>, <code>\"</code>, <code>'</code>) - Removes Trackmania link formatting <code>$l[...]</code> and highlight codes <code>$l</code> and <code>$h</code> - Replaces double hyphens <code>--</code> with an HTML entity to avoid XML comment trouble</p> <p>Use this when rendering user content in Twing templates or Manialinks</p> <pre><code>title = htmlEntities(map.Name);\n</code></pre>"},{"location":"devs/class/utils/#removelinks-removecolors","title":"removeLinks / removeColors","text":"<p>Helpers to strip link and color formatting.</p>"},{"location":"devs/class/utils/#cloneobj","title":"clone(obj)","text":"<p>Return deep clone using JSON serialization.</p>"},{"location":"devs/class/utils/#formattimems","title":"formatTime(ms)","text":"<p>Return Trackmania formatted time string for given milliseconds. Uses <code>tm.Time</code> helper.</p>"},{"location":"devs/class/utils/#casttypevalue-type","title":"castType(value, type?)","text":"<p>Convert a string into the requested type. If <code>type</code> is not provided, the function guesses the type (true/false/null/number/string).</p>"},{"location":"devs/class/utils/#setmemstart-meminfo","title":"setMemStart / memInfo","text":"<p>Helpers for memory measurement and reporting useful for GC debugging.</p>"},{"location":"devs/class/utils/#isdocker","title":"isDocker()","text":"<p>Detect if process runs inside Docker container.</p>"},{"location":"devs/class/utils/#getcallername","title":"getCallerName()","text":"<p>Helper that logs the call site invoking code using V8 stack trace utilities (used for debugging and <code>tmc.cli</code> trace behavior when DEBUGLEVEL &gt;= 3).</p>"},{"location":"devs/class/utils/#escaperegex-logintouuid-uuidtologin","title":"escapeRegex / loginToUuid / uuidToLogin","text":"<p>Misc helpers to escape regex patterns and convert login &lt;-&gt; uuid encodings.</p> <p>Best practices: - Always use <code>htmlEntities()</code> when injecting user-provided content into Manialinks and templates. - Use <code>removeColors()</code> to compute string comparisons or localeCompare without formatting codes. - Prefer <code>parseEntries()</code> to convert API array payloads into objects rather than manual parsing.</p>"},{"location":"devs/example-plugin/","title":"Example Plugin","text":"<p>This sample plugin demonstrates several features for plugin authors:</p> <ul> <li>Registering commands (public and admin)</li> <li>Demonstrating ListWindow and Widget UIs</li> <li>Using <code>tmc.billMgr</code> to create SendBill transactions and lifecycle callbacks</li> <li>Using settings and colors via <code>this.addSetting</code> and <code>this.addColor</code></li> <li>Using <code>tmc.ui.setClipboard</code> to copy text into player's clipboard</li> </ul> <p>Commands:</p> <ul> <li><code>/ex-hello</code> \u2014 Greet the player with greeting from <code>example.greeting</code> setting</li> <li><code>/ex-msg &lt;target&gt; &lt;message&gt;</code> \u2014 Send a private chat message to <code>target</code></li> <li><code>/ex-list</code> \u2014 Show a ListWindow of connected players</li> <li><code>/ex-copy</code> \u2014 Copy the current map UID into player's clipboard</li> <li><code>//ex-bill &lt;target&gt; &lt;amount&gt; &lt;message&gt;</code> \u2014 Admin-only command: create a bill to <code>target</code> for <code>amount</code> with message</li> <li><code>//ex-admin</code> \u2014 Admin-only example command</li> </ul> <p>Developer notes:</p> <ul> <li>The plugin uses <code>import.meta.dirname</code> to resolve its template paths.</li> <li>Settings and colors registered using plugin base methods will be cleaned up automatically on plugin destroy.</li> </ul> <p>How to test:</p> <p>1) Start the controller 2) Ensure <code>userdata/plugins/example-plugin</code> exists or install it via <code>tmc.installPlugin(\"path/to/example-plugin\")</code>. 3) Run <code>await tmc.loadPlugin('example-plugin')</code> during runtime. 4) Try <code>/ex-hello</code> or <code>/ex-list</code> from the in-game chat. For admin commands, use an admin account and <code>//ex-bill</code>.</p>"},{"location":"users/install/","title":"Install","text":"<p>Back to Index</p>"},{"location":"users/install/#install-minicontrol","title":"Install MINIcontrol","text":"<p>This guide walks through installing and running MINIcontrol using either a native Node/Bun environment or Docker. It covers prerequisites, environment configuration, database migrations, and running the controller in development or production.</p>"},{"location":"users/install/#prerequisites","title":"Prerequisites","text":"<ul> <li>Node.js &gt;= 21.5.0 (recommended) and npm, or Bun. The runtime uses <code>tsx</code> for TypeScript execution.</li> <li>Git (for cloning the repository)</li> <li>A supported database. By default MINIcontrol uses SQLite (no external DB server required), but PostgreSQL and MySQL are supported.</li> <li>Docker &amp; Docker Compose (optional \u2014 recommended for production or reproducible deployments)</li> </ul>"},{"location":"users/install/#quick-start-node-bun","title":"Quick Start (Node / Bun)","text":"<ol> <li>Clone the repository (see above) and change into the folder.</li> <li>Install dependencies:</li> </ol> <pre><code>npm install --production\n</code></pre> <ol> <li>Copy the example environment file and configure it.  PowerShell (Windows) and Bash examples are shown.</li> </ol> <p>PowerShell (Windows):</p> <pre><code>Copy-Item .env.example .env\n</code></pre> <p>Bash (Linux, macOS):</p> <pre><code>cp .env.example .env\n# Edit .env to set your XMLRPC host/user/password and database config\n</code></pre> <p>Important entries in <code>.env</code> (basic):</p> Variable Default Description XMLRPC_HOST \"127.0.0.1\" Hostname or IP of the Trackmania server (or container name in Docker) XMLRPC_PORT 5000 RPC port for your server XMLRPC_USER \"SuperAdmin\" Superadmin login (from the server config) XMLRPC_PASS \"SuperAdmin\" Password for the RPC account DATABASE <code>sqlite://userdata/local.sqlite</code> DB connection string: sqlite, postgres or mysql URL ADMINS (empty) Comma-separated logins with admin permissions in MINIcontrol PLUGINS (empty) Inclusive whitelist of plugin IDs to load; use <code>\"\"</code> to allow auto-discovery DEBUG false Basic debugging flags for the runtime ANSILEVEL 1 Log color level: 0 none, 1 4-bit, 2 24-bit <ol> <li>Start the controller</li> </ol> <pre><code>npm start\n</code></pre> <p>For development with Bun (fast startup &amp; hot reload), use:</p> <pre><code>npm run dev\n</code></pre>"},{"location":"users/install/#quick-tldr-one-liner-setup","title":"Quick TL;DR \u2014 One-liner setup","text":"<pre><code>git clone https://github.com/EvoEsports/minicontrol.git &amp;&amp; cd minicontrol &amp;&amp; npm install --production &amp;&amp; cp .env.example .env &amp;&amp; npm start\n</code></pre> <p>PowerShell (Windows):</p> <pre><code>git clone https://github.com/EvoEsports/minicontrol.git; Set-Location ./minicontrol; npm install --production; Copy-Item .env.example .env; npm start\n</code></pre> <p>Note: <code>start:bun</code> script is available if you prefer to run Bun directly.</p> <pre><code># Use Bun to install and run with the example env\nbun install\nbun --env-file .env ./core/minicontrol.ts\n</code></pre>"},{"location":"users/install/#commands-cheat-sheet","title":"Commands cheat-sheet","text":"Command Purpose npm install Install dependencies npm run dev Run with Bun in dev/watch mode (hot reload) npm start Start production controller (uses tsx) npm run migrate Run local migrations (requires env configured) npm run migrate:docker Run migrations inside the Docker container docker compose -f docker/compose.yml up -d --build Build and start the Docker environment docker compose -f docker/compose.yml logs -f minicontrol Follow controller logs"},{"location":"users/install/#docker-recommended-for-production-easy-setup","title":"Docker (recommended for production / easy setup)","text":"<p>MINIcontrol includes an example Docker Compose in <code>docker/compose.yml</code>. It demonstrates how to run a Trackmania server (TmForever) and the controller in separate containers.</p> <ol> <li>Build the Docker image (from repo root):</li> </ol> <pre><code># Build the minicontrol image\ndocker build -t minicontrol:latest -f docker/Dockerfile .\n</code></pre> <ol> <li>Or use docker compose to build &amp; run:</li> </ol> <pre><code># from repo root\ndocker compose -f docker/compose.yml up -d --build\n</code></pre> <ol> <li> <p>The example compose file sets <code>XMLRPC_HOST: trackmania</code> so the controller can communicate with the local Trackmania container. It also mounts <code>userdata</code> to persist configuration and plugin files across container restarts.</p> </li> <li> <p>To view logs:</p> </li> </ol> <pre><code>docker compose -f docker/compose.yml logs -f minicontrol\n</code></pre> <ol> <li>To run migrations inside the Docker environment:</li> </ol> <pre><code># Run migrations inside the running container\ndocker compose -f docker/compose.yml exec minicontrol npm run migrate:docker\n</code></pre> <p>Tip: Make sure you configure <code>XMLRPC_USER</code> and <code>XMLRPC_PASS</code> in the compose environment or the <code>.env</code> file so MiniControl can authenticate with the server.</p>"},{"location":"users/install/#database-migrations","title":"Database &amp; migrations","text":"<p>MINIcontrol uses Umzug and Sequelize for schema management. By default, the controller uses SQLite, but you can switch to Postgres or MySQL by setting the <code>DATABASE</code> environment variable to a proper DB URL.</p> <p>Local migration (recommended after <code>.env</code> configuration):</p> <pre><code>npm run migrate\n</code></pre> <p>In Docker:</p> <pre><code>docker compose -f docker/compose.yml exec minicontrol npm run migrate:docker\n</code></pre> <p>Notes: - Migrations are applied automatically on startup, but running the scripts manually can help during CI and debugging. - For production, prefer a dedicated PostgreSQL / MySQL instance to avoid SQLite file locking and to allow backups.</p>"},{"location":"users/install/#plugin-management-plugins-variable","title":"Plugin management &amp; <code>PLUGINS</code> variable","text":"<p>By default MINIcontrol discovers plugins under <code>core/plugins/</code> and <code>userdata/plugins/</code>.</p> <p><code>PLUGINS</code> is an inclusive (whitelist) environment variable: if provided it will only load the listed plugin IDs and their explicitly listed dependencies. If <code>PLUGINS</code> is not set or is empty, the controller will attempt to discover and load all compatible plugins.</p> <p>Examples:</p> <pre><code>PLUGINS=\"admin,announces\"\n</code></pre> <p>Use wildcards for nested plugins:</p> <pre><code>PLUGINS=\"kacky,kacky/*,widgets/records\"\n</code></pre> <p>Important: When using <code>PLUGINS</code> explicitly, include required dependencies in the list (e.g., include <code>database</code> if your plugin depends on it); otherwise the resolver will mark the plugin as missing dependencies.</p> <p>Examples combining dependencies and wildcards:</p> <pre><code>PLUGINS=\"database,kacky,kacky/*,widgets/records\"\n</code></pre> <p>Setting an empty value has the same effect as not setting <code>PLUGINS</code> at all (all compatible plugins will be loaded):</p> <pre><code>PLUGINS=\"\"\n</code></pre>"},{"location":"users/install/#managing-the-controller","title":"Managing the controller","text":"<ul> <li>Start: <code>npm start</code> or <code>docker compose -f docker/compose.yml up -d</code></li> <li>Stop: <code>Ctrl+C</code> (local) or <code>docker compose -f docker/compose.yml down</code> (Docker)</li> <li>Restart (Docker): <code>docker compose -f docker/compose.yml restart</code></li> </ul> <p>Use a process manager (systemd, pm2, or Docker) in production for monitoring and restarts.</p> <p>Admin CLI commands in-game (as SuperAdmin): - <code>//plugins</code> \u2014 show plugin manager UI - <code>//plugin load &lt;id&gt;</code> \u2014 load a plugin - <code>//plugin unload &lt;id&gt;</code> \u2014 unload a plugin - <code>//plugin reload &lt;id&gt;</code> \u2014 reload a plugin</p>"},{"location":"users/install/#verifying-your-installation","title":"Verifying your installation","text":"<ol> <li>Ensure the <code>XMLRPC_HOST</code> / port / credentials match your dedicated server.</li> <li>Verify that the controller is able to connect and authenticate:</li> </ol> <pre><code># Run the controller and watch logs for successful connection and 'Connected to Trackmania Dedicated server.' message\nnpm start\n</code></pre> <ol> <li>Confirm your plugins are loaded: check the <code>//plugins</code> command in-game or <code>tmc.discoverPlugins()</code> in dev console.</li> </ol> <p>If all else fails, check logs (<code>docker logs</code> or console output), and open an issue with reproduction steps.</p> <p>For additional details and examples see:</p> <ul> <li>Dev: Quickstart plugin</li> <li>Developer docs and class references</li> </ul>"},{"location":"users/install/#example-env-minimal","title":"Example .env (minimal)","text":"<p>Copy <code>.env.example</code> and fill values you need. Minimal example for local testing using SQLite:</p> <pre><code>XMLRPC_HOST=127.0.0.1\nXMLRPC_PORT=2350\nXMLRPC_USER=SuperAdmin\nXMLRPC_PASS=your_password_here\nDATABASE=sqlite://userdata/local.sqlite\nADMINS=MyLogin\n# Optional: PLUGINS=\"admin,announces\"\nPLUGINS=\n</code></pre> <p>Tip: On Windows use PowerShell <code>Copy-Item .env.example .env</code> instead of <code>cp</code></p>"},{"location":"users/install/#troubleshooting-expanded","title":"Troubleshooting (expanded)","text":"<ul> <li>Cannot connect / authentication errors: verify <code>XMLRPC_*</code> credentials, service names in Docker (<code>XMLRPC_HOST</code>), and ensure the server accepts XML-RPC connections for your version.</li> <li>Plugins not loaded: check <code>PLUGINS</code> whitelist, plugin <code>manifest.json</code> and semver compatibility with <code>requiresMinicontrolVersion</code>.</li> <li>DB migration failures: confirm <code>DATABASE</code> URL and run migrations manually (<code>npm run migrate</code> or <code>docker exec</code> into container to run <code>npm run migrate:docker</code>).</li> <li><code>SendDisplayManialinkPage</code> or Manialink issues: check <code>uimanager</code> logs for template parsing errors and confirm your server version matches the UI API.</li> <li>For permission errors in-game, ensure <code>ADMINS</code> covers the login you are using.</li> </ul> <p>If the issue persists, please provide logs (console or <code>docker logs</code>) and a copy of your <code>.env</code> with secrets removed.</p>"},{"location":"users/install/#production-hints-security","title":"Production hints &amp; security","text":"<ul> <li>Do not commit <code>.env</code> or secrets to the repository.</li> <li>Use a managed DB (Postgres / MySQL) for production and configure backups.</li> <li>Use TLS / reverse proxies for HTTP frontends if exposing a UI or webhooks.</li> <li>Use a process manager (systemd/pm2) or Docker orchestrator to ensure restarts and log collection.</li> </ul>"},{"location":"users/install/#getting-help-reporting-issues","title":"Getting help &amp; reporting issues","text":"<ul> <li>Join our Discord server for real-time help and developer discussion.</li> <li>Open a bug report or feature request on GitHub: https://github.com/EvoEsports/minicontrol/issues</li> <li>Read the developer docs under <code>documentation/devs/</code> for plugin development guidance and API references.</li> </ul>"},{"location":"users/install/#feedback-contributions","title":"Feedback &amp; contributions","text":"<p>If you\u2019d like to contribute improvements (docs, tests, or code), please open an issue before sending a PR \u2014 we\u2019ll gladly help you align with the project\u2019s goals.</p>"},{"location":"users/plugins/","title":"Plugins","text":"<p>Back to Index</p>"},{"location":"users/plugins/#minicontrol-core","title":"MINIcontrol Core","text":"Command Description <code>/help</code> Display help for public commands <code>//help</code> Display help for admin commands <code>//plugin list</code> displays all plugins currently loaded runtime <code>//plugin load &lt;name&gt;</code> loads plugin to runtime <code>//plugin unload &lt;name&gt;</code> unloads plugin from runtime <code>//plugin reload &lt;name&gt;</code> reloads plugin <code>//shutdown</code> closes controller <code>/serverlogin</code> shows server login <code>/version</code> show version numbers for titlepack, server and controller"},{"location":"users/plugins/#admin","title":"Admin","text":"<p>When loaded, Admin plugin provides simple chat-driven admin interface for server administration.</p>"},{"location":"users/plugins/#available-commands","title":"Available commands","text":""},{"location":"users/plugins/#available-in-trackmania2020-and-maniaplanet","title":"Available in Trackmania2020 and Maniaplanet","text":"Command Description <code>//modesettings</code> Open scripted gamemode settings window <code>//set</code> [setting] [value] Set modesetting <p>Available globally:</p>"},{"location":"users/plugins/#players","title":"Players","text":"Command Description <code>//kick</code> [login] Kicks player <code>//ban</code> [login] Bans a player <code>//unban</code> [login] unbans a player <code>//ignore</code> [login] Mute player <code>//unignore</code> [login] Unmute player"},{"location":"users/plugins/#maps","title":"Maps","text":"Command Description <code>//shuffle</code> Shuffle the playlist <code>//wml</code> [file] Save the playlist <code>//rml</code> [file] Load a saved playlist <code>//skip</code> Skips a map <code>//res</code> Restarts map <code>//talimit</code> [seconds] Sets time limit ta-mode <code>//remove</code> [mapid] Remove a map from the playlist, mapid is optional see /list for mapid <code>//jump</code> [mapid] Remove a map from the playlist, mapid is optional see /list for mapid"},{"location":"users/plugins/#server","title":"Server","text":"Command Description <code>//cancel</code> Cancel a vote <code>//er</code> End round <code>//mode</code> [rounds,ta,team,laps,cup,stunts] Sets gamemode (stunts not available for scripted modes) <code>//setpass</code> [password] Sets password for the server, use syntax: \"if you need spaces\" <code>//setspecpass</code> [password] Sets specator password for the server <code>//warmup</code> [nb] Sets warmup duration <code>//call</code> [method] [parameter1] [parameter2] Call server method"},{"location":"users/plugins/#announces","title":"Announces","text":"<p>Shows player join and leave messages.</p>"},{"location":"users/plugins/#bestcps","title":"BestCps","text":"<p>Shows at middle-top best checkpoints time.</p>"},{"location":"users/plugins/#chat","title":"Chat","text":"<p>Customize chat appearance.</p>"},{"location":"users/plugins/#debugtool","title":"Debugtool","text":"<p>Shows useful memory information ingame and console for developers.</p>"},{"location":"users/plugins/#tmnfdedimania","title":"Tmnf/Dedimania","text":"<p>\u2139\ufe0f Only available with TmForever</p> <p>Adds Dedimania records system for the server.</p> Command Description <code>/dedirecords</code> Shows complete list of records"},{"location":"users/plugins/#fun-commands","title":"Fun commands","text":"<p>Adds some funny commands.</p> Command Description <code>/afk</code> Go afk <code>/bootme</code> Boot yourself <code>/ragequit</code> Rage quit <code>/bwoah</code> BWOAH <code>/gg</code> Good game <code>/ty</code> Thanks <code>/gn</code> Good night <code>/bb</code> Bye <code>/go</code> Go go go <code>/n1</code> Nice one <code>/nt</code> Nice time <code>/posture</code> Posture Check <code>/hydrate</code> Hydrate Check"},{"location":"users/plugins/#mapwidget","title":"MapWidget","text":"<p>Provides a custom widget to top right edge of screen with current map info.</p>"},{"location":"users/plugins/#records","title":"Records","text":"<p>\u26a0\ufe0f Depends on database / API credentials</p> <p>Provides live / local world records for the server</p> Command Description <code>/records</code> show local records <code>/liverankings</code> show live records <code>/worldrecords</code> show world records"},{"location":"users/plugins/#checkpoints","title":"Checkpoints","text":"<p>Shows full best checkpoint times</p> Command Description <code>/checkpoints</code> shows best checkpoints"},{"location":"users/plugins/#tmnftalimit","title":"Tmnf/talimit","text":"<p>\u2139\ufe0f Only available with TmForever</p> <p>Provides custom ta timelimit functions for the server, like extends.</p>"},{"location":"users/plugins/#tmnfui","title":"Tmnf/ui","text":"<p>\u2139\ufe0f Only available with TmForever</p> <p>Removes some parts of the UI to make more clean HUD</p>"},{"location":"users/plugins/#tmx","title":"TMX","text":"<p>Trackmania Exchange integration plugin.</p>"},{"location":"users/plugins/#tmforever","title":"TmForever","text":"<p>[!INFO] Supported site parameters: TMO, TMS, TMN, TMNF, TMUF</p> Command Description <code>//add &lt;id:site&gt;</code> Adds map or comma separated list of maps from TMX. <code>//addpack &lt;id:site&gt;</code> Adds mappack from TMX."},{"location":"users/plugins/#maniaplanet-trackmania","title":"ManiaPlanet / Trackmania","text":"Command Description <code>//add &lt;id&gt;</code> Adds map or comma separated list of maps from TMX. <code>//addpack &lt;id&gt;</code> Adds mappack from TMX."},{"location":"users/plugins/#votes","title":"Votes","text":"<p>Provides voting.</p> Command Description <code>/skip</code> start vote to skip map <code>/extend</code> start vote to extend <code>/res</code> start vote to restart map <code>/yes</code> vote yes <code>/no</code> vote no <code>//vote &lt;custom,skip,extend,res&gt; \"question here\"</code> start custom, extend or skip vote <code>//extend &lt;seconds&gt;</code> force extend map in seconds, can be negative <code>//pass</code> force pass vote <code>//cancel</code> force cancel vote"}]}